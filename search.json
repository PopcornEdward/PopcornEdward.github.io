[{"categories":null,"content":"js-异步场景总结和一些优质代码展示 简介 Generator 的主要用途是实现异步编程，因此常用于客户端和服务端的异步操作中。以下是一些常见的使用场景：\n客户端：在客户端中，Generator 可以用于处理复杂的用户交互逻辑、动画效果等。例如，在一个需要用户输入多个步骤的表单中，可以使用 Generator 来暂停函数的执行，等待用户完成当前步骤后再继续执行下一步。\n服务端：在服务端中，Generator 可以用于处理复杂的异步操作，例如数据库查询、文件读写等。通过使用 Generator，可以避免回调地狱的问题，并使异步代码更加易读易维护。\n需要注意的是，现在已经有更加简洁易用的异步编程方式，例如 async/await，因此在实际开发中，使用 Generator 的场景可能会相对较少。不过，如果你想深入了解 JavaScript 异步编程的原理和实现方式，学习 Generator 仍然是非常有价值的。\n在前端中，Generator 可以用于异步编程，可以通过使用 yield 关键字来暂停函数的执行，并且可以在需要时恢复执行。这样可以避免使用回调函数和 Promise 等方式来处理异步操作，使代码更加简洁易读。\n下面是一个简单的例子，演示了如何使用 Generator 实现异步编程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function* fetchData() { const response = yield fetch('https://jsonplaceholder.typicode.com/todos/1'); const data = yield response.json(); console.log(data); } const generator = fetchData(); const promise = generator.next().value; promise.then(response =\u003e { return generator.next(response).value; }).then(data =\u003e { generator.next(data); }); 在上面的例子中，fetchData 函数定义了一个 Generator，其中包含了两个异步操作：第一个操作是使用 fetch 方法获取数据，第二个操作是将获取到的数据转换成 JSON 格式。通过使用 yield 关键字，我们可以在每个异步操作完成后暂停函数的执行，并将结果传递给下一个异步操作。在主程序中，我们首先获取 Generator 的实例，并调用 next 方法，以启动第一个异步操作。接着，我们使用 then 方法来处理异步操作的结果，并将结果传递给下一个异步操作，以此类推，直至所有异步操作完成。\n需要注意的是，Generator 在前端中的应用并不常见，因为现代浏览器已经支持了更加简洁易用的异步编程方式，例如 async/await。\n惰性计算通常用于处理大量数据或者需要频繁操作的数据集合，以避免不必要的计算和内存占用。以下是一些可能会用到惰性计算的业务场景：\n数据库查询：当需要查询大量数据时，可以使用惰性计算来避免一次性将所有数据都加载到内存中，而是在需要时逐个获取数据。\n数据流处理：当需要对数据流进行处理时，可以使用惰性计算来避免一次性将所有数据都加载到内存中，而是在需要时逐个处理数据。\n图像处理：当需要处理大量图像时，可以使用惰性计算来避免一次性将所有图像都加载到内存中，而是在需要时逐个处理图像。\n日志处理：当需要处理大量日志时，可以使用惰性计算来避免一次性将所有日志都加载到内存中，而是在需要时逐个处理日志。\n总之，如果你需要处理大量数据或者需要频繁操作的数据集合，那么惰性计算可能是一个非常有用的工具，可以帮助你节省内存和提高效率。\n惰性计算 示例 以下是一个使用 Generator 实现的惰性计算示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function* lazyFilter(arr, predicate) { for (let i = 0; i \u003c arr.length; i++) { if (predicate(arr[i])) { yield arr[i]; } } } const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; const evenNumbers = lazyFilter(numbers, num =\u003e num % 2 === 0); for (let number of evenNumbers) { console.log(number); } 在这个示例中，我们定义了一个 lazyFilter 生成器函数，它接受一个数组和一个用于过滤元素的谓词函数。在 lazyFilter 函数内部，我们使用 for 循环遍历数组，并在满足谓词函数的条件时使用 yield 关键字将当前元素返回。这样，我们可以通过调用 lazyFilter 函数来创建一个惰性计算的迭代器对象，而不必立即对整个数组进行计算。最后，我们通过 for...of 循环遍历迭代器对象，并依次输出符合条件的元素。\n需要注意的是，这个示例只是一个简单的惰性计算示例，实际应用中可能需要更复杂的逻辑和处理方式。\n数据库查询 假设我们有一个包含用户信息的数据库，我们可以使用惰性计算来实现查询操作。首先，我们定义一个函数 getUserById，它接收一个用户ID作为参数，并返回一个函数，该函数会在调用时查询数据库并返回对应的用户信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const getUserById = (id) =\u003e { let user = null; return () =\u003e { if (!user) { console.log(`Querying database for user ${id}`); // 假设这里是查询数据库的代码 user = { id, name: 'Alice', age: 25 }; } return user; }; }; // 使用惰性计算查询用户信息 const user = getUserById(123)(); console.log(user); 数据流处理 假设我们有一个数据流，其中包含一些数字。我们可以使用惰性计算来实现对这些数字进行过滤和转换的操作。首先，我们定义一个函数 filter，它接收一个过滤函数作为参数，并返回一个函数，该函数会在调用时对数据流进行过滤。\n1 2 3 4 5 6 7 8 9 10 11 const filter = (predicate) =\u003e { return (data) =\u003e { console.log(`Filtering data stream`); return data.filter(predicate); }; }; // 使用惰性计算过滤数据流 const data = [1, 2, 3, 4, 5]; const filteredData = filter(x =\u003e x % 2 === 0)(data); console.log(filteredData); 在这个示例中，我们使用惰性计算来避免对整个数据流进行过滤，而是只在需要时才进行计算。\n图像处理 假设我们有一个图像，我们可以使用惰性计算来实现对图像进行缩放和旋转的操作。首先，我们定义一个函数 scale，它接收一个缩放比例作为参数，并返回一个函数，该函数会在调用时对图像进行缩放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const scale = (factor) =\u003e { let image = null; return () =\u003e { if (!image) { console.log(`Loading image`); // 假设这里是加载图像的代码 image = { width: 100, height: 100 }; } console.log(`Scaling image by factor ${factor}`); return { width: image.width * factor, height: image.height * factor }; }; }; // 使用惰性计算缩放图像 const scaledImage = scale(2)(); console.log(scaledImage); 在这个示例中，我们使用闭包来保存图像信息，以便在下一次缩放时可以直接返回，而不必重新加载和处理图像。\n日志处理 假设我们有一个应用程序，我们可以使用惰性计算来实现对日志进行记录和过滤的操作。首先，我们定义一个函数 log，它接收一个日志级别作为参数，并返回一个函数，该函数会在调用时记录日志。\n1 2 3 4 5 6 7 8 9 const log = (level) =\u003e { return (...args) =\u003e { console.log(`[${level}]`, ...args); }; }; // 使用惰性计算记录日志 const debug = log('DEBUG'); debug('Debug message'); 在这个示例中，我们使用惰性计算来避免在不需要记录日志时进行计算，从而提高程序的性能和效率。\n","description":"","tags":null,"title":"Js 异步场景总结和一些优质代码展示","uri":"/posts/2023/06/09/js-%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93%E5%92%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E8%B4%A8%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA/"},{"categories":null,"content":"win10-pnpm+astro安装指南 步骤 全局安装pnpm命令 npm i -g pnpm\n验证pnpm是否成功 pnpm -v\n安装astro创建新项目 pnpm create astro@latest\n常见问题 1. 如果遇到Error: unable to verify the first certificate这类报错 解决方案1 set NODE_TLS_REJECT_UNAUTHORIZED=0 执行完上面这句后可以正常创建astro\n解决方案2 去如下网站下载pem证书\nhttps://letsencrypt.org/zh-cn/certificates/\n","description":"","tags":null,"title":"Pnpm And Astro Win Setup Guide","uri":"/posts/2023/05/29/pnpm-and-astro-win-setup-guide/"},{"categories":null,"content":"当今，人工智能技术正在飞速发展，越来越多的企业和组织都开始将其应用于自己的业务中。为了更好地推广和应用人工智能技术，越来越多的人工智能社区和平台被创建出来。其中一个非常重要的平台就是AIGC（AI Global Community）。\nAIGC是一个由全球各地的人工智能专家、企业家、学者和爱好者组成的社区。该社区致力于推广和应用人工智能技术，以帮助企业和组织更好地实现数字化转型。AIGC提供了一系列的服务和资源，包括培训课程、技术支持、交流活动、合作机会等等。\n作为一个开放的社区，AIGC欢迎所有对人工智能感兴趣的人加入。无论你是一名学生、一名研究人员、一名企业家，还是一名爱好者，你都可以在AIGC中找到自己的位置。在这里，你可以结识志同道合的人，分享你的经验和知识，学习最新的技术和应用案例，甚至找到合作伙伴和商业机会。\n除了为个人和企业提供服务和资源之外，AIGC还致力于推动人工智能技术的发展和应用。该社区定期举办各种形式的交流活动，包括技术分享、论坛、研讨会、比赛等等。这些活动不仅可以促进人工智能领域的交流和合作，还可以为人工智能技术的发展提供更多的思路和资源。\n总之，AIGC是一个非常重要的人工智能社区和平台。它为个人和企业提供了丰富的服务和资源，同时也在推动人工智能技术的发展和应用。如果你对人工智能感兴趣，那么加入AIGC将是一个非常明智的选择。\n","description":"","tags":null,"title":"大时代 AIGC的到来","uri":"/posts/2023/05/24/%E5%A4%A7%E6%97%B6%E4%BB%A3-aigc%E7%9A%84%E5%88%B0%E6%9D%A5/"},{"categories":null,"content":"私服开源工具推荐 Nexus Verdaccio 例子按照Verdaccio的步骤进行拆解 服务器上部署verdaccio和注册私服帐号 linux centos 中安装 docker Verdaccio 的镜像，到dockerHub站点下载 配置 持久化进程守护的方式运行 verdaccio的服务 verdaccio服务部署好后配置文件会返回一个web访问地址如：http://192.168.1.109:4873 先用浏览器访问下该网址，确保服务可以正常访问 网站首页不一定有新增用户的入口（我用的v4.12.2是没有找到） 这步开始提供一种创建npm私服帐号的方法（步骤如下） 6.1 新建一个空文件夹 6.2 执行npm init -y 6.3 在当前文件夹下shell命令执行 npm adduser --registry=http://192.168.1.109:4873 6.4 username: [新用戶名] 6.5 password: [新密碼] 6.6 会提示注册和登陆成功 6.7 npm publish 上传测试下是否成功 6.8 如果成功了，上传测试到这结束，如果失败看下什么原因有可能是403的一些错误 npm工具包的.npmrc文件配置详解 它的作用是设置 npm 的行为和默认的选项 这里可以把私服的访问地址和私服帐号设置进去，这样每次发包的时候就方便多了\n配置参考如下：（.npmrc） @yh-hl:registry=http://192.168.1.109:4873/ # Verdaccio email=marklow@126.com always-auth=true _auth=\"guest:H95sTgGHI0ua6\" Verdaccio私服帐号的信息如何查看获取 docker ps [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6294fd19f092 verdaccio/verdaccio:4 \"uid_entrypoint /bin…\" 3 hours ago Up 3 hours 0.0.0.0:4873-\u003e4873/tcp inspiring_yalow 6ed8324ed2bc minio/minio \"/usr/bin/docker-ent…\" 4 weeks ago Up 8 days 0.0.0.0:9000-\u003e9000/tcp minio c9aa4f612175 kibana:7.3.2 \"/usr/local/bin/dumb…\" 7 months ago Up 8 days 0.0.0.0:5601-\u003e5601/tcp kibana 6473edbef510 elasticsearch:7.3.2 \"/usr/local/bin/dock…\" 7 months ago Up 8 days 0.0.0.0:9200-\u003e9200/tcp, 0.0.0.0:9300-\u003e9300/tcp es docker exec -it 6294fd19f092 /bin/sh 切换到 root 根目录下 / ~ $ pwd /opt/verdaccio ~ $ cd / 如果之前步骤新用户新建成功的话，这时在 /verdaccio/storage 目录下会有 htpasswd 文件 打开 htpasswd 文件 出现如下内容： guest:H95sTgGHI0ua6:autocreated 2023-05-04T07:38:14.151Z ~ ~ ~ ~ 复制 guest:H95sTgGHI0ua6 粘贴至 .npmrc的_auth参数上（H95sTgGHI0ua6 这个编码是由之前步骤注册用户的时候系统自动生成的，如果要自己生成则可以用 htpasswd工具进行生成后再添加至 /verdaccio/storage/htpasswd 文件内，保存后要重启docker的verdaccio服务） npm包发包和发版详解 如我开发的fusion-cli这个包每次改动完后第1步提交改动至git仓库 如果是小改动则执行 npm version patch,其它版本号的迭代查看npm version --help 执行npm publish 存在的问题和补充内容 要先改动提交有commit记录了才能发包 发包前必须要修改npm版本号 工具包依赖的其它依赖要用npm i -S来安装，否则其它用户下载了这个包，执行的时候会少工具包相关的依赖，则运行错误 ","description":"","tags":null,"title":"关于npm私有包的上传流程","uri":"/posts/2023/05/04/%E5%85%B3%E4%BA%8Enpm%E7%A7%81%E6%9C%89%E5%8C%85%E7%9A%84%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"需求： 我要下载这个版本的代码到当前目录下，不要创建yibao-ui目录\n改进下这句\ngit clone –branch v1.0.0 –depth=1 –no-checkout https://{repository_url} \u0026\u0026 git sparse-checkout init –cone \u0026\u0026 git sparse-checkout set {your_folder_path} 我要下载这个版本的代码到当前目录下，不要创建yibao-ui目录\n好的，那么可以这样改进这段命令：\ngit clone –branch v1.0.0 –depth=1 –no-checkout https://{repository_url} . \u0026\u0026 git sparse-checkout init –cone \u0026\u0026 git sparse-checkout set {your_folder_path} 这里使用了 . 表示当前目录，也就是代表将代码下载到当前目录下而不是新建一个名为 yibao-ui 的目录。\ngit clone –branch v1.0.0 –depth=1 http://guest:123456@192.168.1.109:3008/Ta404ManageFrontUI_Temp_Libs/yibao-ui.git . \u0026\u0026 git sparse-checkout init –cone \u0026\u0026 git sparse-checkout set yibao-ui\n","description":"","tags":null,"title":"Git 操作的一些常用命令","uri":"/posts/2023/04/28/git-%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":" 接口名称 请求方法 请求路径 请求参数 返回结果 GetAccessToken POST /users/:username/tokens 用户名和密码 用户 Token CheckCurrentPassword POST /user/password 旧的密码 状态码 CreateAccessToken POST /user/tokens 无 用户 CreateMilestone POST /repos/:owner/:repo/milestones 里程碑数据\t里程碑 CreateOrg POST /admin/orgs\t组织数据\t组织信息 CreateRelease POST /repos/:owner/:repo/releases\t发布信息\t发布 ID CreateRepo POST /user/repos\t仓库信息\t仓库信息 CreateTeam POST /orgs/:org/teams\t团队数据\t团队信息 CreateUser POST /admin/users\t用户信息\t用户信息 DeleteArchive DELETE /repos/:owner/:repo/archive\t无\t归档文件 DeleteIssueComment DELETE /repos/:owner/:repo/issues/comments/:id\t无\t状态码 DeleteMilestone DELETE /repos/:owner/:repo/milestones/:id\t无\t状态码 DeleteOrg DELETE /admin/orgs/:name\t无\t状态码 DeletePublicKey DELETE /user/keys/:id\t无\t状态码 DeleteRelease DELETE /repos/:owner/:repo/releases/:id\t无\t状态码 DeleteRepo DELETE /repos/:owner/:repo\t无\t状态码 DeleteTeam DELETE /orgs/:org/teams/:id\t无\t状态码 DeleteUser DELETE /admin/users/:name\t无\t状态码 EditIssueComment PATCH /repos/:owner/:repo/issues/comments/:id\t评论内容\t状态码 EditMilestone PATCH /repos/:owner/:repo/milestones/:id\t里程碑数据\t里程碑 EditOrg PATCH /admin/orgs/:name\t组织数据\t组织信息 EditPublicKey PATCH /user/keys/:id\t无\t状态码 EditRelease PATCH /repos/:owner/:repo/releases/:id\t发布内容\t发布 ID EditRepo PATCH /repos/:owner/:repo\t仓库信息\t仓库信息 EditTeam PATCH /orgs/:org/teams/:id\t团队数据\t团队信息 EditUser PATCH /admin/users/:name\t用户信息\t用户信息 GetBlob GET /repos/:owner/:repo/git/blobs/:sha\t无\tBlob 内容 GetBranch GET /repos/:owner/:repo/branches/:branch\t无\t分支信息 GetCommit GET /repos/:owner/:repo/git/commits/:sha\t无\t提交信息 GetDownload GET /repos/:owner/:repo/downloads/:id\t无\t下载信息 GetIssue GET /repos/:owner/:repo/issues/:index\t无\t问题 GetIssueComment GET /repos/:owner/:repo/issues/comments/:id\t无\t评论 GetKey GET /user/keys/:id\t无\t公钥信息 GetMilestone GET /repos/:owner/:repo/milestones/:id\t无\t里程碑 GetOrg GET /orgs/:org\t无\t组织信息 GetPullRequest GET /repos/:owner/:repo/pulls/:index\t无\t拉取请求 GetReadme GET /repos/:owner/:repo/readme\t无\tREADME 文件 GetRelease GET /repos/:owner/:repo/releases/:id\t无\t发布 GetRepo GET /repos/:owner/:repo\t无\t仓库信息 GetTag GET /repos/:owner/:repo/git/tags/:sha\t无\t标签 GetTeam GET /orgs/:org/teams/:id\t无\t团队信息 GetUser GET /users/:name\t无\t用户信息 ListArchive GET /repos/:owner/:repo/archive\t无\t归档文件列表 ListBranches GET /repos/:owner/:repo/branches\t无\t分支列表 ListCommits GET /repos/:owner/:repo/commits\t无\t提交列表 ListDownloads GET /repos/:owner/:repo/downloads\t无\t下载列表 ListForks GET /repos/:owner/:repo/forks\t无\t仓库分叉列表 ListIssueComments GET /repos/:owner/:repo/issues/:index/comments\t无\t评论列表 ListIssues GET /repos/:owner/:repo/issues\t无\t问题列表 ListKeys GET /user/keys\t无\t公钥列表 ListMilestones GET /repos/:owner/:repo/milestones\t无\t里程碑列表 ListMyRepos GET /user/repos\t无\t我的仓库列表 ListOrgRepos GET /orgs/:org/repos\t无\t组织的仓库列表 ListPullRequests GET /repos/:owner/:repo/pulls\t无\t拉取请求列表 ListReleases GET /repos/:owner/:repo/releases\t无\t发布列表 ListTags GET /repos/:owner/:repo/git/tags\t无\t标签列表 ListTeams GET /orgs/:org/teams\t无\t团队列表 ListUserRepos GET /users/:name/repos\t无\t用户的仓库列表 ListUsers GET /users\t无\t用户列表 Search GET /repos/search\t查询参数\t仓库列表 Upload POST /repos/:owner/:repo/releases/:id/assets\t文件\t资源位置 ","description":"","tags":["gogs"],"title":"Try Gogs官网swagger所有接口表","uri":"/posts/2023/04/27/try-gogs%E5%AE%98%E7%BD%91swagger%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E8%A1%A8/"},{"categories":null,"content":" 要获取Gogs中当前组织当前仓库下所有的tags标签，你可以使用Git命令来实现。以下是一些示例命令：\n获取所有标签： 1 git fetch --tags 获取指定仓库的所有标签： 1 git fetch --tags \u003c仓库地址\u003e 获取指定组织和仓库的所有标签： 1 git fetch --tags \u003c组织\u003e/\u003c仓库\u003e 执行这些命令后，你将看到所有可用的标签列表，包括它们的SHA哈希值和提交信息。 若要获得更详细的信息，请使用以下命令：\n1 git tag -n 这将显示标签的名称、SHA哈希、作者、日期和注释。\n","description":"","tags":["gogs","git"],"title":"Gogs 获取当前仓库下所有的tags标签","uri":"/posts/2023/04/27/gogs-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BB%93%E5%BA%93%E4%B8%8B%E6%89%80%E6%9C%89%E7%9A%84tags%E6%A0%87%E7%AD%BE/"},{"categories":null,"content":"gogs-日志的命令详解 1. gogs linux 用nohup 只输出错误日志怎么写 可以使用如下命令，在执行gogs时使用nohup，并将标准输出重定向到/dev/null：\n1 nohup /path/to/gogs \u003e /dev/null 2\u003e\u00261 \u0026 这样，标准输出会被重定向到/dev/null，只有错误输出会被保存在nohup.out文件中。如果要保存错误输出到其他文件，可以将 “2\u003e\u00261”修改为“2\u003e/path/to/error.log”来指定输出文件路径。\n2. bash: ./log/error.log: 权限不够 这个问题是因为当前用户对./log目录下的error.log文件没有写入的权限所导致的。\n要解决这个问题，你可以通过以下步骤尝试获得权限：\n以管理员身份使用chmod命令给用户赋予写入权限，例如： 1 sudo chmod u+w ./log/error.log 这会将./log/error.log文件赋予当前用户可写入的权限。\n如果以上命令仍旧提示权限不够，那么则需要使用sudo命令以管理员身份重新执行原始命令。例如： 1 sudo ./your_command.sh 这会使用管理员身份执行你所需要的命令，从而让你可以顺利地写入./log/error.log文件。 如果以上命令依旧无法解决问题，建议先看看是否可以将文件写入到当前用户的家目录下，或者是否需要先创建相应的目录并赋予适当的权限。\nlinux给创建的文件赋予读写权限 要给一个文件赋予读写权限，你需要使用chmod命令。使用方法如下：\n1 chmod +rw \u003cfilename\u003e 例如，要给位于/home/user/document路径下的file.txt文件赋予读写权限，你可以使用如下命令：\n1 chmod +rw /home/user/document/file.txt 这会将file.txt文件赋予当前用户可读写的权限。注意，如果你希望给文件赋予执行权限，你可以使用+x选项而非+rw选项。\n如果你想同时修改一个目录下所有文件的权限，你可以添加-R选项，例如：\n1 chmod -R +rw /home/user/document/ 这会将/home/user/document/路径下的所有文件和子目录赋予当前用户可读写的权限。\nlinux git用户组没有很多权限 touch文件也不行，应该怎么赋予权限 当使用git用户组时，默认情况下，该组的成员只拥有Git相关操作的权限，并且不允许在git仓库中创建或修改文件。\n如果你希望在git仓库中创建或修改文件，你可以将git用户添加到另一个组中，该组具有所需的文件操作权限。你可以在命令行中使用以下命令将git用户添加到其他用户组中（请替换groupname为所需的组名）：\n1 sudo usermod -a -G groupname git 在将git用户添加到所需的组后，你需要确保该组拥有文件的读写权限。你可以在命令行中使用以下命令更改文件的权限：\n1 sudo chmod g+rw filename 这将赋予文件owner用户组与其他组可读可写权限。如果你需要给文件的owner用户赋予相同的权限，你可以使用以下命令：\n1 sudo chmod u+rw filename 这将给文件的owner用户可读可写权限。请注意，更改文件权限可能会导致安全问题，请确保你只向正确的用户或组授予权限。\n如果你需要对一个目录中的所有文件都执行权限更改，请使用-R选项（例如：sudo chmod -R g+rw directoryname）。\n","description":"","tags":["vim","gogs","linux"],"title":"Gogs 日志的命令详解","uri":"/posts/2023/04/26/gogs-%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"Hugo - 用于构建 Web 站点的快速静态站点生成器 用法 Hugo [命令]\n通用命令: version 显示 Hugo 版本号。 config 输出网站配置。 env 输出环境信息。 check 检查您的内容。 benchmark 在站点中运行基准测试。 new 在 content 目录中创建新站点资源。 gen (re)生成您的网站。 其他命令: undraft 从将内容草稿中发布。 delete 删除可通过 source 目录访问的内容。 server 启动一个服务器来在本地预览站点。 new theme 在 themes 目录中创建新主题资源。 convert 转换您的站点以使用不同的前端。 构建命令: hugo 在默认情况下创建您的站点。 hugo server 在本地机器上启动服务器。 hugo check 以查找您的网站的问题输出您的网站信息。 hugo mod clean 删除本地代理模块中的所有缓存数据。 hugo mod get 使用特定的版本替换现有的模块。 hugo mod init 将模块支持添加到站点。 hugo mod tidy 根据模块支持更新 go.mod 文件，以获取最新的版本。 hugo mod vendor 安装站点的所有模块的本地副本。 全局标志 (标记): -v, --verbose 长格式: --verbose 显示详细错误。启用此标记会导致 Hugo 输出更多信息。 -s, --source 长格式: --source 指定源目录(默认为当前工作目录)。 -d, --destination 长格式: --destination 指定输出目录 (默认为 $ {根路径}/public/)。 -b, --baseURL 长格式: --baseURL 设置网站项目的基本 URL。 --appendPort 像基本 URL 添加一个端口。 --buildDrafts 包括在草稿、隐藏内容及其它内容中的内容，以供构建时查看。 --buildFuture 包括计划发布日期大于现在的文章。 --buildExpired 包括已过期的文章。 --disableRSS 禁用 RSS 支持。 --disableSitemap 禁用 Sitemap 支持。 --enableGitInfo 启用 Git 信息。 --cleanDestinationDir 配置 Hugo 是否应该删除生成的文件夹中存在但在源目录中不存在的现有目录。默认为 false。 --forceSyncStatic 在同步静态文件时强制重新复制所有文件。 --ignoreCache 忽略磁盘和内存缓存，并忽略文件系统通知。 --isUTF8 将内容视为UTF-8 值。默认为 true。 --layoutDir 指定布局目录 (默认为 $ {源目录}/layouts)。 --log 将 Hugo 写入文件中，而不是 默认的 stderr。 --minify 将资源（HTML、CSS、JS 等）缩小。 --noChmod 禁止修改文件权限。 --noTimes 禁止使用文件修改时间。 --path-warnings 路径映射过程中的错误和警告。 --pluck 在显示时显示指定字段。 --quiet 静音输出。 --renderToMemory 在内存中渲染站点。 --templateMetrics 当渲染模板时输出计时器。 --templateMetricsHints 如果为真，则在模板计时器输出中包含源位置。 --uglyURLs 生成丑陋的 URL。请参阅网站网址。 --verboseLog 指定要记录的详细度。 --verboseLogFiles 指定基于文件日志的详细度。 这些和其他标志可以在命令行中使用来定制您的 Hugo 网站构建。\n","description":"","tags":null,"title":"Hugo Help命令详解","uri":"/posts/2023/04/21/hugo-help%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"目录 配置 简码 单页模板/部分 i18n 造型 用法 结论\n这篇文章介绍了雨果主题的另一个增强功能 - 目录 （TOC）。它基于 Hugo 的内置功能，可以解析 Markdown 内容并生成可在模板中使用的目录。本文是“雨果主题食谱”系列的第二篇。\n通常，我的教程或文章从介绍部分开始。然后是详细步骤或实现细节，其中每个部分都以 H3（） 标题为标题。为了使我的文章中的导航更容易，在介绍部分之后，我向以下部分添加了锚链接列表;例如，链接将对应于标题为 .这样的清单只不过是一个目录。###Install Hugo### Install Hugo\n因此，我想自动创建目录，而不是手动添加锚链接列表。这可以通过使用 Hugo 的内置功能自动解析 Markdown 内容并创建目录来实现。基于此功能，我实现了一个解决方案，该解决方案允许使用简码或页面模板显示目录。\n因此，让我们检查一下此解决方案的详细信息。我在下面描述的实现的源代码可以在我对 Bilberry 主题的贡献中找到。\n配置 要定义目录中需要包含的标题级别，您必须将以下内容添加到站点配置文件中，例如：config.toml\n1 2 3 4 5 [markup] [markup.tableOfContents] startLevel = 2 endLevel = 5 ordered = false 该设置定义 Hugo 开始呈现目录时的标题级别。设置当 Hugo 停止生成目录时的标题级别（包括）。在上面的配置中，从 H2（） 到 H5（）（包括 H\u003c\u003e（） 和 H\u003c\u003e（）的所有标题都将用于创建目录。该设置确定要生成的列表类型，即使用标记的有序列表或使用标记的无序列表。\n简码 根据 Hugo 文档，如果您的降价中有适当的标题，Hugo 将提取它们并存储在名为 的页面变量中。 由于它只能在 Go 模板中使用，因此您不能仅放置在内容文件中并期望显示目录。您可以做的是将其包装在简码中。在站点根目录中，创建包含以下内容的文件：.TableOfContents.TableOfContentslayouts/shortcodes/toc.html\n1 {{ .Page.TableOfContents }} 单页模板/部分 然后，您可以更进一步，完全自动化目录的创建。То 这样做，首先，您需要将前言变量添加到默认原型模板中，该模板用于在 Hugo 主题中创建空内容文件。在Bilberry 主题中，它是原型/default.md。变量的默认值应设置为 ：toc toc false\n1 toc: false 其次，如果要根据内容中的字数使TOC呈现成为条件，请将参数添加到站点配置文件中并设置您认为合适的值，例如：tocMinWordCount500\n1 2 3 [param] # Minimum word count to display the Table of Contents tocMinWordCount = 500 第三，在单页模板中，在显示内容之前添加以下代码片段：\n1 2 3 4 {{ if and (.Params.toc) (gt .WordCount .Site.Params.tocMinWordCount ) }} \u003ch2\u003e{{ i18n \"tableOfContents\" }}\u003c/h2\u003e {{ .TableOfContents }} {{ end }} 例如，一个简单的页面模板可能如下所示：layout/_default/single.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {{ define \"main\" }} \u003cmain\u003e \u003carticle\u003e \u003cheader\u003e \u003ch1\u003e{{ .Title }}\u003c/h1\u003e \u003c/header\u003e {{ if and (.Params.toc) (gt .WordCount .Site.Params.tocMinWordCount ) }} \u003ch2\u003e{{ i18n \"tableOfContents\" }}\u003c/h2\u003e {{ .TableOfContents }} {{ end }} {{ .Content }} \u003c/article\u003e \u003c/main\u003e {{ end }} 因此，在上面的示例中，仅当满足以下条件时，才会呈现目录：\n页面变量设置为toctrue 内容中的字数大于“站点配置”设置中定义的值tocMinWordCount 内容具有适当的标题，这些标题在 和 站点配置设置定义的范围内startLevelendLevel i18n 由于该函数用于显示标签，因此请在相应的 i18n 配置文件中为键定义一个值，例如 i18n/en.toml：i18nTable of ContentstableOfContents\n1 2 [tableOfContents] other = \"Table of Contents\" 造型 最后，最后要做的是使用 CSS 设置变量生成的 HTML 输出的样式。HTML 输出由一个具有子元素（或取决于设置）的元素组成，该子元素又包含一个带有元素列表的子 /。每个都包含一个指向相应内容标题的元素。 下面是此类 HTML 的示例：\n1 2 3 4 5 6 7 8 9 10 11 \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e \u003cli\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#header-h2-1\"\u003eHeader H2 1\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#header-h2-2\"\u003eHeader H2 2\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#header-h2-3\"\u003eHeader H2 3\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e 如何设置目录的样式在很大程度上取决于您使用的主题。在我的 Bilberry 主题中，样式是使用 SCSS 语法实现的，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #TableOfContents { display: block; background: transparent; padding-bottom: 2rem; font-size: 1.2em; ul { display: list-item; padding-left: 0; \u0026:not(:first-child) { display: list-item; padding-left: 0.9rem; font-size: 95%; } } li { display: inherit; color: $text-color; a { color: inherit; text-align: left; padding: 0; \u0026:hover { color: $highlight-color; background-color: transparent; } } } } 具有上述样式的目录将如下所示：\n[图片]\n用法 如果要在降价内容中的特定点显示目录，请使用简码：toc.html\n1 {{ \u003ctoc\u003e }} 如果要在内容的开头显示目录，请将页面变量设置为 ：toc true\n1 toc: true 结论 总而言之，所提出的解决方案提供了两个用于自动创建目录的选项。您可以使用其中之一或两者。简码方法更直接，对您选择的雨果主题的实现的依赖性更小。此外，您可以将简码放置在降价内容中的任何位置。另一方面，单页模板/部分方法更依赖于主题，并且生成的目录在显示的内容中具有固定的位置。不过，只需启用相应的页面变量即可更轻松地使用。\n","description":"","tags":null,"title":"将目录添加到Hugo主题","uri":"/posts/2023/04/21/%E5%B0%86%E7%9B%AE%E5%BD%95%E6%B7%BB%E5%8A%A0%E5%88%B0hugo%E4%B8%BB%E9%A2%98/"},{"categories":null,"content":" 一种所有浏览器都支持的新方法，用于将颜色存储在 CSS 变量中并使用 SASS 函数对其进行修改。\nCSS变量很棒 我们都知道这一点。HSL 颜色值是最好的。同意！SASS颜色功能很棒。是的，没什么新鲜事。但是如何结合这些东西并在今天使用它们呢？有办法！\n我们为我们的框架开发了一种新的方法，该方法将本机变量（存储HSL颜色值）的灵活性与SASS函数的实用性相结合。\n👋 您第一次听说CodyHouse框架吗？ * 开始使用 * 浏览组件 * 全球编辑 问题所在 在我们的框架中，我们使用CSS变量。我们集成了 postcss-css-variables 插件的修改版本，为不支持它们的浏览器生成回退。我们更喜欢 CSS 变量而不是 SASS 变量，因为您可以在特定断点（或使用类）覆盖它们的值。事实证明，此功能对于开发我们的响应式间距和排版系统以及颜色主题特别有用。\n也就是说，以下是我们在启动框架（v 1.0.0）时定义颜色变量的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 :root, [data-theme=\"default\"] { // main --color-primary-darker: hsl(220, 90%, 36%); --color-primary-dark: hsl(220, 90%, 46%); --color-primary: hsl(220, 90%, 56%); --color-primary-light: hsl(220, 90%, 66%); --color-primary-lighter: hsl(220, 90%, 76%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); --color-accent-darker: hsl(355, 90%, 41%); --color-accent-dark: hsl(355, 90%, 51%); --color-accent: hsl(355, 90%, 61%); --color-accent-light: hsl(355, 90%, 71%); --color-accent-lighter: hsl(355, 90%, 81%); // color contrast --color-bg: hsl(0, 0%, 100%); --color-bg-a00: hsla(0, 0%, 100%, 0); --color-contrast-lower: hsl(0, 0%, 95%); --color-contrast-low: hsl(240, 1%, 83%); --color-contrast-medium: hsl(240, 1%, 48%); --color-contrast-high: hsl(240, 4%, 20%); --color-contrast-higher: hsl(240, 8%, 12%); --color-contrast-higher-a90: hsla(240, 8%, 12%, 0.9); // semantic --color-border: var(--color-contrast-low); // ... } HSL 颜色值很棒，因为它们使创建颜色变化变得直观。只需编辑色调、饱和度和亮度值。这些数字很容易阅读。\n但是，当我们开始处理组件时，我们意识到没有简单的方法来设置颜色的 alpha 值：\n1 2 3 .component { background-color: hsla(var(--color-primary), 0.2); // not working 😥 } 您可以将 CSS 变量包含在 SASS mixins 和函数中，但上面的代码会返回一个无效的值（–var（color） 被 hsl（x，x%，x%） 替换）。\n如何解决这个问题？\n测试 #1 - 将 CSS color-mod 函数与 PostCSS 插件🙅🏻 ♂️一起使用 首先，我们尝试使用 CSS原生颜色函数。\n1 2 3 .component { background-color: color-mod(var(--color-primary) alpha(20%)); } 它们很整洁，但远未得到主要浏览器的支持。我们尝试集成一些PostCSS插件来生成回退，但没有运气。我们在最终输出中不断出现错误，因此我们认为这种方法太不可靠了。\n测试 #2 - 为 alpha 值🙅🏻 ♂️设置 CSS 变量 因为我们的问题无法为颜色设置不透明度值，所以第二个方法是为 alpha 值创建 CSS 变量：\n1 2 3 4 :root, [data-theme=\"default\"] { --color-primary: hsl(220, 90%, 56%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); } 在组件级别，您可以通过应用 alpha 变量来设置 alpha 值：\n1 2 3 .component { background-color: var(--color-primary-a20); } 请记住，目标是将所有颜色值存储到单个文件中，以便整个系统易于维护。我们不能只在组件级别使用 hsla。_colors.scss\n虽然我们不是100%相信这个解决方案，但我们决定在框架的第一个版本中采用它。\n新解决方案 - 创建 SASS 混合蛋白以清理颜色混乱 🎉 事实证明，为 alpha 值创建变量是一个糟糕的解决方案，主要有两个原因：\n如果您在组件级别工作，则每当想要对颜色使用不同的 Alpha 值时，都必须切换到该文件。_colors.scss 因为我们的系统基于颜色主题（颜色是可互换的），所以如果你为一种颜色创建一个 alpha 变量，你必须对所有其他颜色做同样的事情。 我们又回到了原点。 以下是最终得到我们认为是一个很好的解决方案的过程：首先，我们尝试使用 mixin 来指定 alpha 值。此混合需要 3 个变量：、 和 。$property$color-variable$opacity\n我们会像这样使用mixin：\n1 2 3 .component { @include alpha(background-color, --color-primary, 0.2); } 虽然这是mixin的代码：\n1 2 3 4 5 6 @mixin alpha($property, $color-variable, $opacity) { $color-variable-h: var(#{$color-variable+'-h'}); $color-variable-s: var(#{$color-variable+'-s'}); $color-variable-l: var(#{$color-variable+'-l'}); #{$property}: hsla($color-variable-h, $color-variable-s, $color-variable-l, $opacity); } 为此，我们需要为每种颜色设置 3 个变量：\n:root, [data-theme=\"default\"] { --color-primary: hsl(220, 90%, 56%); --color-primary-h: 220; --color-primary-s: 90%; --color-primary-l: 56%; } 其中是色调值，是饱和度百分比，是亮度百分比（不，我们不想放弃HSL颜色值☝️）。--color-name-h--color-name-s--color-name-l\n仍然太复杂了，但我们正在到达某个地方。\n在这一点上，我们想出了创建我们自己的alpha SASS函数来替换mixin的想法。这将允许我们以更友好的方式编写 CSS 声明：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); } 下面是函数的代码：\n// return css color variable with different opacity value @function alpha($color, $opacity){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsla($color-h, $color-s, $color-l, $opacity); } // replace substring with another string // credits: https://css-tricks.com/snippets/sass/str-replace-function/ @function str-replace($string, $search, $replace: '') { $index: str-index($string, $search); @if $index { @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace); } @return $string; } 越来越近！困扰我们的最后一件事是必须为每种颜色（色调、饱和度、亮度）手动创建 3 个附加变量。这很烦人，因为您必须在修改颜色时更新这些变量的值。\n啊哈时刻意识到我们可以使用 SASS mixin 来定义每种颜色，以便我们可以在 CSS 中自动生成色调、饱和度和亮度值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @mixin defineColorHSL($color, $hue, $saturation, $lightness){ #{$color}: unquote(\"hsl(#{$hue}, #{$saturation}, #{$lightness})\");#{$color}-h: #{$hue};#{$color}-s: #{$saturation};#{$color}-l: #{$lightness}; } :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary, 220, 89%, 56%); @include defineColorHSL(--color-accent, 355, 90%, 61%); @include defineColorHSL(--color-black, 240, 8%, 12%); @include defineColorHSL(--color-white, 0, 0%, 100%); // color contrasts @include defineColorHSL(--color-bg, 0, 0%, 100%); @include defineColorHSL(--color-contrast-lower, 0, 0%, 95%); @include defineColorHSL(--color-contrast-low, 240, 1%, 83%); @include defineColorHSL(--color-contrast-medium, 240, 1%, 48%); @include defineColorHSL(--color-contrast-high, 240, 4%, 20%); @include defineColorHSL(--color-contrast-higher, 240, 8%, 12%); } 这种方法的好处是，您仍然以易于理解的语法声明颜色，并允许您创建修改 HSL 值的颜色变体：\n1 2 3 4 5 6 7 :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary-darker, 220, 90%, 36%); @include defineColorHSL(--color-primary-dark, 220, 90%, 46%); @include defineColorHSL(--color-primary, 220, 90%, 56%); @include defineColorHSL(--color-primary-light, 220, 90%, 66%); @include defineColorHSL(--color-primary-lighter, 220, 90%, 76%); } 如何在组件级别设置 alpha 值 在 SCSS 中，您可以使用 alpha 函数设置不透明度值：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); // it works 🎉 } 它有效🙌！我们刚刚推送了一个框架更新（v 1.1.0），其中包括新的mixins和一个更新的文件。_colors.scss\n使用此方法创建其他颜色函数 由于此方法允许您访问和修改色调、饱和度、亮度和 alpha 值，因此您可以为每个值创建一个函数！\n编辑亮度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function lightness($color, $lightnessMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, $color-s, calc(#{$color-l} * #{$lightnessMultiplier})); } .component { background-color: lightness(var(--color-primary), 1.2); } 编辑饱和度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function saturation($color, $saturationMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, calc(#{$color-s} * #{$saturationMultiplier}), $color-l); } .component { background-color: saturation(var(--color-primary), 1.2); } 结语 我们框架的主要目标是简化启动 Web 项目的过程。我们觉得我们正在朝着这个目标前进。如果您对我们可以改进的地方有任何建议，请与我们联系！欢迎任何反馈。\n","description":"","tags":["sass"],"title":"如何用SASS颜色函数和CSS变量","uri":"/posts/2023/04/19/%E5%A6%82%E4%BD%95%E7%94%A8sass%E9%A2%9C%E8%89%B2%E5%87%BD%E6%95%B0%E5%92%8Ccss%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"hugoTemplate Template 变量 在 Hugo 的模板中，变量是可扩展的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{ $variable := \"hello world\" }} {{/* 访问变量 */}} {{ $variable }} {{/* 进行计算 */}} {{ $sum := 1 + 1 }} {{ $sum }} {{/* 两个变量相加 */}} {{ $valueOne := 1 }} {{ $valueTwo := 2 }} {{ $result := add $valueOne $valueTwo }} {{ $result }} 内部变量 除了你自己定义的变量，Hugo 也会在模板中自动创建一些内部变量，以便在渲染页面时为你提供有用的信息。这些变量通常用于控制网站的样式和页面布局，以及访问站点中的内容和元数据。\n以下是一些常见的内部变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 {{/* 站点元数据 */}} {{ .Site.Title }} {{ .Site.Params.author }} {{ .Site.Params.description }} {{/* 页面元数据 */}} {{ .Title }} {{ .Params.date }} {{ .Params.author }} {{ .Description }} {{ .Type }} {{ .Content }} {{/* 访问站点的相关页面 */}} {{ .Site.GetPage \"section\" \"blog\" }} {{ .Site.GetPage \"url\" \"/\" }} {{ .Site.GetPage \"permalink\" \"/blog/\" }} {{/* 访问站点相关资源 */}} {{ .Site.GetPage \"page\" \"/css/styles.css\" }} {{ .Site.GetPage \"page\" \"/images/banner.jpg\" }} {{/* 迭代站点相关内容 */}} {{ range .Data.Pages }} {{ .Render \"summary\" }} {{ end }} {{/* 参数定位 */}} {{ $.Param \"foo\" }} 访问指定字段 在 Hugo 模板中，你可以访问网站元数据和内容页面中的字段并将其用于渲染。 1 2 3 4 5 6 7 {{ .Site.Params.author }} {{ .Site.Params.description }} {{ .Title }} {{ .Content }} {{ .Params.date }} {{ .Params.author }} {{ .Params.tags }} 变量 每个Go模板获得一个数据对象。在Hugo中，每个模板都传递一个Page。在下面的示例中，. title是Page变量中可访问的元素之一。由于Page是模板的默认作用域，因此当前作用域中的Title元素(。-“点”)可以通过点前缀(.Title)访问:\n1 \u003ctitle\u003e{{ .Title }}\u003c/title\u003e 值也可以存储在自定义变量中并在以后引用:\n自定义变量需要以$作为前缀。 1 2 {{ $address := \"123 Main St.\" }} {{ $address }} 变量可以使用=操作符重新定义。下面的示例在主页上打印“Var is Hugo Home”，在所有其他页面上打印“Var is Hugo page”:\n1 2 3 4 5 {{ $var := \"Hugo Page\" }} {{ if .IsHome }} {{ $var = \"Hugo Home\" }} {{ end }} Var is {{ $var }} ","description":"","tags":["Hugo"],"title":"Hugo Template 变量的定义","uri":"/posts/2023/04/19/hugo-template-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"categories":null,"content":" 如果您对 Hugo 主题进行了修改，并且希望将这些修改提交到 Git 仓库中，则应该考虑以下两种情况： 如果您从 Hugo 主题库中下载了某个主题，并在其基础上进行修改，则建议在您自己的 Git 仓库中提交修改。这样，您可以更轻松地管理您所做的所有修改，并随时更新该主题的原始版本。\n如果您在 GitHub 中发现了某个 Hugo 主题，并且您对该主题进行了修改，则可以考虑 fork 该主题的仓库，并将您所做的修改提交到 fork 的仓库中。当您的修改被审核后，您可以提交 pull request 到原始仓库中，以便作者将您的修改合并到主题中。\n需要注意的是，无论您将修改提交到哪个仓库中，都需要遵循开源许可协议和作者的许可条件。如果您不确定是否可以在特定情况下进行修改，请查看主题的文档和许可证。 ","description":"","tags":["Hugo"],"title":"Hugo Themes主题文件有修改改动的内容应该提交到哪个git仓库呢","uri":"/posts/2023/04/19/hugo-themes%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E6%9C%89%E4%BF%AE%E6%94%B9%E6%94%B9%E5%8A%A8%E7%9A%84%E5%86%85%E5%AE%B9%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BA%A4%E5%88%B0%E5%93%AA%E4%B8%AAgit%E4%BB%93%E5%BA%93%E5%91%A2/"},{"categories":null,"content":" Hugo 的语法文档可以在 Hugo 官方网站（https://gohugo.io/documentation/）上找到，您可以根据需要查看以下文档：\n快速入门（https://gohugo.io/getting-started/quick-start/）介绍了如何安装 Hugo 并创建新的站点。 Hugo 基础语法（https://gohugo.io/content-management/syntax/）文档详细介绍了 Hugo 的基本语法，如如何创建页面、如何定义页面元数据、如何使用 Markdown 语法等。 主题开发文档（https://gohugo.io/templates/）介绍了如何使用 Hugo 模板来创建自定义主题。 内容管理文档（https://gohugo.io/content-management/organization/）介绍了如何组织和管理站点内容。 部署文档（https://gohugo.io/hosting-and-deployment/) 介绍了如何将站点部署到各种平台和服务上，包括 GitHub Pages、Netlify、Amazon S3 等。 在 Hugo 官方网站上，您还可以找到其他相关文档和资源，例如社区主题和插件，以及 Hugo 的 GitHub 存储库。此外，Hugo 的文档是开源的，您也可以在 Hugo 的 GitHub 存储库（https://github.com/gohugoio/hugo）中找到完整的文档源码。 ","description":"","tags":["Hugo"],"title":"Hugo 语法文档哪里看","uri":"/posts/2023/04/19/hugo-%E8%AF%AD%E6%B3%95%E6%96%87%E6%A1%A3%E5%93%AA%E9%87%8C%E7%9C%8B/"},{"categories":null,"content":" section 2 section 2.1 section 2.2 section 2.3 section 2 section 2.1 section 2.2 section 2.3 如果您在 Git 中添加了一个子模块，但是现在要卸载它，可以按照以下步骤执行：\n删除 .gitmodules 文件中子模块的条目。 打开 .gitmodules 文件并找到您要删除的子模块条目，然后将其删除。例如： 1 2 3 [submodule \"path/to/submodule\"] path = path/to/submodule url = https://github.com/username/repo.git ","description":"","tags":["git"],"title":"Git Submodule 卸载模块","uri":"/posts/2023/04/18/git-submodule-%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Hugo自定义短代码 在 Hugo 中，你可以使用自定义短代码来生成模板中的动态内容。自定义短代码是一段用于生成特定内容的模板代码片段，这个代码片段可以通过简单的一行代码在模板中调用。\n下面是一个简单的例子，演示如何在 Hugo 中定义和使用自定义短代码。我们将定义一个短代码 {{myShortcode }}，并让它生成一段简单的 HTML。\n在 Hugo 的根目录下，创建一个名为 layouts/shortcodes 的文件夹。\n在 layouts/shortcodes 文件夹中，创建一个名为 myShortcode.html 的文件。\n在 myShortcode.html 文件中，添加以下代码片段：\n1 \u003cp\u003eThis is my custom shortcode!\u003c/p\u003e 在模板中使用自定义短代码 **{{{myShortcode }}}。**例如： 1 2 3 4 5 6 7 8 9 10 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e{{ .Title }}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e {{\u0026#123;myShortcode \u0026#125;}} \u003c/body\u003e \u003c/html\u003e 在浏览器中查看生成的页面，你应该看到 “This is my custom shortcode!” 这段文字。 总的来说，自定义短代码是一个十分有用的功能，它让你可以在 Hugo 中轻松地生成各种动态内容。\n","description":"","tags":["Hugo"],"title":"Hugo自定义短代码","uri":"/posts/2023/04/18/hugo%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%AD%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":" 变量 描述 .Site 网站级别的变量，用于存储网站的全部信息，包括站点标题、url、作者等信息。 Site.BuildDrafts 如果设置为 true，则 Hugo 会对所有草稿页面进行构建。 Site.BuildFuture 如果设置为 true，则 Hugo 会对将来发布的页面进行构建。 Site.BuildExpired 如果设置为 true，则 Hugo 会对过期的页面进行构建。 Site.Charset 设置网站的字符编码，默认为 utf-8。 Site.LanguageCode 设置网站的语言代码，默认为 en-us。 Site.Title 网站标题。 Site.Params 网站中自定义的变量的命名空间，可以在配置文件中定义。 Site.Menus 网站菜单项的配置项。 Site.Home 网站首页的配置项。 Site.Pages 网站中所有页面的集合。 Site.RegularPages 网站中所有“正式”页面的集合，不包括草稿、过期等页面。 Site.AllPages 网站中所有页面（包括草稿、过期等）的集合。 Site.Data 网站中的数据文件。 Site.Taxonomies 网站中分类和标签的信息。 Site.Taxonomies. 网站中指定分类或标签的信息， 为分类或标签的名称。 .CurrentDate 当前时间，格式为 2006-01-02。 .Date 文章的日期。 .PublishDate 文章的发布日期。 .ExpiryDate 文章的过期日期。 .Lastmod 文章最后修改时间。 .Permalink 页面的永久链接。 .FuzzyWordCount 计算页面的模糊字数（即忽略 HTML、注释等元素的总字数）。 .PageNumber 如果在多页列表中，则为当前页面的序号。 .Paginate 分页器的配置信息。 .Paginator 分页器的结构体变量。 .WordCount 页面的总字数。 .Title 文章或页面的标题。 .Description 文章或页面的描述。 .Summary 文章或页面的摘要。 .Content 页面的主要内容。 .Params 页面的自定义变量的命名空间，可以在 Markdown 页面中定义。 .Site.Params. 等同于 .Params.，但是在 Hugo 中建议使用前者。 .Resources 页面中的资源，如图片、CSS、JavaScript 等。 .Params. 页面中自定义变量的值，可以在 Markdown 或配置文件中定义。 .ContentBaseName 页面的文件名（不包括扩展名）。 .FileName 页面的文件名（包括扩展名）。 .File 页面的文件信息，包括文件路径、名称、扩展名等。 .Section 当前页面所在的 section 名称，由页面的路径决定。 .Site.GetPage 根据指定路径获取页面信息。 .Site.GetPage 根据指定路径获取页面信息。 .RelLangURL 当前页面在指定语言下的 URL。 .RelPermalink 当前页面的相对 URL。 .RSSLink 当前页面 RSS 订阅的链接。 .Site.Author. 网站作者的信息， 可以是 name、email、bio 等。 .Site.Params. 获取网站中自定义变量的值。 with 可以嵌套在 range 中使用，用于在 range 的作用域内定义变量。 range 遍历集合，并将每个元素赋值给指定变量，可以使用 with 定义变量。 if 条件控制语句。 else 与 if 配合使用，表示 if 条件不成立时执行的语句。 partial 载入指定名称的 partial 方件并进行解析。 block 定义重载块，用于在父模板中指定可用于被子模板覆盖的区域。 define 定义 template 变量。 template 引用指定名称的 template。 shortcode Hugo 中内置的短代码语法，用于快速插入特定块的内容，例如音频、视频、图集等。 ","description":"","tags":["Hugo"],"title":"Hugo的所有变量整理表","uri":"/posts/2023/04/18/hugo%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E6%95%B4%E7%90%86%E8%A1%A8/"},{"categories":null,"content":"hugo new post/ 如果有很多文章了怎么防止创建的时候md文件名重复 在使用 hugo new 命令创建新文章时，可以结合当前的时间戳来避免文件名重复。具体操作如下：\n在 config.toml 或 config.yaml 文件中设置 uglyUrls 为 true，这将使 Hugo 自动生成文件的 URL 格式为 domain.com/post/index.html，而不是默认的 domain.com/post/。 1 2 # config.toml uglyUrls = true 创建新文章时，使用当前的时间戳添加到文件名后面，例如： 1 $ hugo new post/my-new-post-1634090882.md 这里的 1634090882 表示当前的 Unix 时间戳，可以通过以下命令获取：\n1 $ date +%s 如果在命令行中不想手动输入时间戳，可以使用以下命令来自动生成：\n1 $ hugo new post/$(date +%Y-%m-%d)-my-new-post.md 这样会创建一个类似 2022-10-13-my-new-post.md 的文件。\n使用时间戳可以确保每个文件名都不同，避免重复。\n","description":"","tags":["Hugo"],"title":"Hugo New Post Repeat","uri":"/posts/2023/04/18/hugo-new-post-repeat/"},{"categories":null,"content":"asdasda ","description":"","tags":null,"title":"Gndex","uri":"/posts/gndex/"},{"categories":["javascript","前端"],"content":"asdasda-1 sdfadsf asdfasdf\n","description":"","tags":null,"title":"Js20year-1","uri":"/posts/js20year/"},{"categories":null,"content":"00123-1 ","description":"","tags":["Hugo","Vue","React","nodeJS","Notion","blog","life","travel","golang","java","ecmascript","typescript","工程化","Vim"],"title":"我的文章标题-1","uri":"/posts/hello-world/"}]