[{"categories":null,"content":"gogs-日志的命令详解 1. gogs linux 用nohup 只输出错误日志怎么写 可以使用如下命令，在执行gogs时使用nohup，并将标准输出重定向到/dev/null：\n1 nohup /path/to/gogs \u003e /dev/null 2\u003e\u00261 \u0026 这样，标准输出会被重定向到/dev/null，只有错误输出会被保存在nohup.out文件中。如果要保存错误输出到其他文件，可以将 “2\u003e\u00261”修改为“2\u003e/path/to/error.log”来指定输出文件路径。\n2. bash: ./log/error.log: 权限不够 这个问题是因为当前用户对./log目录下的error.log文件没有写入的权限所导致的。\n要解决这个问题，你可以通过以下步骤尝试获得权限：\n以管理员身份使用chmod命令给用户赋予写入权限，例如： 1 sudo chmod u+w ./log/error.log 这会将./log/error.log文件赋予当前用户可写入的权限。\n如果以上命令仍旧提示权限不够，那么则需要使用sudo命令以管理员身份重新执行原始命令。例如： 1 sudo ./your_command.sh 这会使用管理员身份执行你所需要的命令，从而让你可以顺利地写入./log/error.log文件。 如果以上命令依旧无法解决问题，建议先看看是否可以将文件写入到当前用户的家目录下，或者是否需要先创建相应的目录并赋予适当的权限。\nlinux给创建的文件赋予读写权限 要给一个文件赋予读写权限，你需要使用chmod命令。使用方法如下：\n1 chmod +rw \u003cfilename\u003e 例如，要给位于/home/user/document路径下的file.txt文件赋予读写权限，你可以使用如下命令：\n1 chmod +rw /home/user/document/file.txt 这会将file.txt文件赋予当前用户可读写的权限。注意，如果你希望给文件赋予执行权限，你可以使用+x选项而非+rw选项。\n如果你想同时修改一个目录下所有文件的权限，你可以添加-R选项，例如：\n1 chmod -R +rw /home/user/document/ 这会将/home/user/document/路径下的所有文件和子目录赋予当前用户可读写的权限。\nlinux git用户组没有很多权限 touch文件也不行，应该怎么赋予权限 当使用git用户组时，默认情况下，该组的成员只拥有Git相关操作的权限，并且不允许在git仓库中创建或修改文件。\n如果你希望在git仓库中创建或修改文件，你可以将git用户添加到另一个组中，该组具有所需的文件操作权限。你可以在命令行中使用以下命令将git用户添加到其他用户组中（请替换groupname为所需的组名）：\n1 sudo usermod -a -G groupname git 在将git用户添加到所需的组后，你需要确保该组拥有文件的读写权限。你可以在命令行中使用以下命令更改文件的权限：\n1 sudo chmod g+rw filename 这将赋予文件owner用户组与其他组可读可写权限。如果你需要给文件的owner用户赋予相同的权限，你可以使用以下命令：\n1 sudo chmod u+rw filename 这将给文件的owner用户可读可写权限。请注意，更改文件权限可能会导致安全问题，请确保你只向正确的用户或组授予权限。\n如果你需要对一个目录中的所有文件都执行权限更改，请使用-R选项（例如：sudo chmod -R g+rw directoryname）。\n","description":"","tags":["vim","gogs","linux"],"title":"Gogs 日志的命令详解","uri":"/posts/2023/04/26/gogs-%E6%97%A5%E5%BF%97%E7%9A%84%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"Hugo - 用于构建 Web 站点的快速静态站点生成器 用法 Hugo [命令]\n通用命令: version 显示 Hugo 版本号。 config 输出网站配置。 env 输出环境信息。 check 检查您的内容。 benchmark 在站点中运行基准测试。 new 在 content 目录中创建新站点资源。 gen (re)生成您的网站。 其他命令: undraft 从将内容草稿中发布。 delete 删除可通过 source 目录访问的内容。 server 启动一个服务器来在本地预览站点。 new theme 在 themes 目录中创建新主题资源。 convert 转换您的站点以使用不同的前端。 构建命令: hugo 在默认情况下创建您的站点。 hugo server 在本地机器上启动服务器。 hugo check 以查找您的网站的问题输出您的网站信息。 hugo mod clean 删除本地代理模块中的所有缓存数据。 hugo mod get 使用特定的版本替换现有的模块。 hugo mod init 将模块支持添加到站点。 hugo mod tidy 根据模块支持更新 go.mod 文件，以获取最新的版本。 hugo mod vendor 安装站点的所有模块的本地副本。 全局标志 (标记): -v, --verbose 长格式: --verbose 显示详细错误。启用此标记会导致 Hugo 输出更多信息。 -s, --source 长格式: --source 指定源目录(默认为当前工作目录)。 -d, --destination 长格式: --destination 指定输出目录 (默认为 $ {根路径}/public/)。 -b, --baseURL 长格式: --baseURL 设置网站项目的基本 URL。 --appendPort 像基本 URL 添加一个端口。 --buildDrafts 包括在草稿、隐藏内容及其它内容中的内容，以供构建时查看。 --buildFuture 包括计划发布日期大于现在的文章。 --buildExpired 包括已过期的文章。 --disableRSS 禁用 RSS 支持。 --disableSitemap 禁用 Sitemap 支持。 --enableGitInfo 启用 Git 信息。 --cleanDestinationDir 配置 Hugo 是否应该删除生成的文件夹中存在但在源目录中不存在的现有目录。默认为 false。 --forceSyncStatic 在同步静态文件时强制重新复制所有文件。 --ignoreCache 忽略磁盘和内存缓存，并忽略文件系统通知。 --isUTF8 将内容视为UTF-8 值。默认为 true。 --layoutDir 指定布局目录 (默认为 $ {源目录}/layouts)。 --log 将 Hugo 写入文件中，而不是 默认的 stderr。 --minify 将资源（HTML、CSS、JS 等）缩小。 --noChmod 禁止修改文件权限。 --noTimes 禁止使用文件修改时间。 --path-warnings 路径映射过程中的错误和警告。 --pluck 在显示时显示指定字段。 --quiet 静音输出。 --renderToMemory 在内存中渲染站点。 --templateMetrics 当渲染模板时输出计时器。 --templateMetricsHints 如果为真，则在模板计时器输出中包含源位置。 --uglyURLs 生成丑陋的 URL。请参阅网站网址。 --verboseLog 指定要记录的详细度。 --verboseLogFiles 指定基于文件日志的详细度。 这些和其他标志可以在命令行中使用来定制您的 Hugo 网站构建。\n","description":"","tags":null,"title":"Hugo Help命令详解","uri":"/posts/2023/04/21/hugo-help%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"目录 配置 简码 单页模板/部分 i18n 造型 用法 结论\n这篇文章介绍了雨果主题的另一个增强功能 - 目录 （TOC）。它基于 Hugo 的内置功能，可以解析 Markdown 内容并生成可在模板中使用的目录。本文是“雨果主题食谱”系列的第二篇。\n通常，我的教程或文章从介绍部分开始。然后是详细步骤或实现细节，其中每个部分都以 H3（） 标题为标题。为了使我的文章中的导航更容易，在介绍部分之后，我向以下部分添加了锚链接列表;例如，链接将对应于标题为 .这样的清单只不过是一个目录。###Install Hugo### Install Hugo\n因此，我想自动创建目录，而不是手动添加锚链接列表。这可以通过使用 Hugo 的内置功能自动解析 Markdown 内容并创建目录来实现。基于此功能，我实现了一个解决方案，该解决方案允许使用简码或页面模板显示目录。\n因此，让我们检查一下此解决方案的详细信息。我在下面描述的实现的源代码可以在我对 Bilberry 主题的贡献中找到。\n配置 要定义目录中需要包含的标题级别，您必须将以下内容添加到站点配置文件中，例如：config.toml\n1 2 3 4 5 [markup] [markup.tableOfContents] startLevel = 2 endLevel = 5 ordered = false 该设置定义 Hugo 开始呈现目录时的标题级别。设置当 Hugo 停止生成目录时的标题级别（包括）。在上面的配置中，从 H2（） 到 H5（）（包括 H\u003c\u003e（） 和 H\u003c\u003e（）的所有标题都将用于创建目录。该设置确定要生成的列表类型，即使用标记的有序列表或使用标记的无序列表。\n简码 根据 Hugo 文档，如果您的降价中有适当的标题，Hugo 将提取它们并存储在名为 的页面变量中。 由于它只能在 Go 模板中使用，因此您不能仅放置在内容文件中并期望显示目录。您可以做的是将其包装在简码中。在站点根目录中，创建包含以下内容的文件：.TableOfContents.TableOfContentslayouts/shortcodes/toc.html\n1 {{ .Page.TableOfContents }} 单页模板/部分 然后，您可以更进一步，完全自动化目录的创建。То 这样做，首先，您需要将前言变量添加到默认原型模板中，该模板用于在 Hugo 主题中创建空内容文件。在Bilberry 主题中，它是原型/default.md。变量的默认值应设置为 ：toc toc false\n1 toc: false 其次，如果要根据内容中的字数使TOC呈现成为条件，请将参数添加到站点配置文件中并设置您认为合适的值，例如：tocMinWordCount500\n1 2 3 [param] # Minimum word count to display the Table of Contents tocMinWordCount = 500 第三，在单页模板中，在显示内容之前添加以下代码片段：\n1 2 3 4 {{ if and (.Params.toc) (gt .WordCount .Site.Params.tocMinWordCount ) }} \u003ch2\u003e{{ i18n \"tableOfContents\" }}\u003c/h2\u003e {{ .TableOfContents }} {{ end }} 例如，一个简单的页面模板可能如下所示：layout/_default/single.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {{ define \"main\" }} \u003cmain\u003e \u003carticle\u003e \u003cheader\u003e \u003ch1\u003e{{ .Title }}\u003c/h1\u003e \u003c/header\u003e {{ if and (.Params.toc) (gt .WordCount .Site.Params.tocMinWordCount ) }} \u003ch2\u003e{{ i18n \"tableOfContents\" }}\u003c/h2\u003e {{ .TableOfContents }} {{ end }} {{ .Content }} \u003c/article\u003e \u003c/main\u003e {{ end }} 因此，在上面的示例中，仅当满足以下条件时，才会呈现目录：\n页面变量设置为toctrue 内容中的字数大于“站点配置”设置中定义的值tocMinWordCount 内容具有适当的标题，这些标题在 和 站点配置设置定义的范围内startLevelendLevel i18n 由于该函数用于显示标签，因此请在相应的 i18n 配置文件中为键定义一个值，例如 i18n/en.toml：i18nTable of ContentstableOfContents\n1 2 [tableOfContents] other = \"Table of Contents\" 造型 最后，最后要做的是使用 CSS 设置变量生成的 HTML 输出的样式。HTML 输出由一个具有子元素（或取决于设置）的元素组成，该子元素又包含一个带有元素列表的子 /。每个都包含一个指向相应内容标题的元素。 下面是此类 HTML 的示例：\n1 2 3 4 5 6 7 8 9 10 11 \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e \u003cli\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"#header-h2-1\"\u003eHeader H2 1\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#header-h2-2\"\u003eHeader H2 2\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"#header-h2-3\"\u003eHeader H2 3\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e 如何设置目录的样式在很大程度上取决于您使用的主题。在我的 Bilberry 主题中，样式是使用 SCSS 语法实现的，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #TableOfContents { display: block; background: transparent; padding-bottom: 2rem; font-size: 1.2em; ul { display: list-item; padding-left: 0; \u0026:not(:first-child) { display: list-item; padding-left: 0.9rem; font-size: 95%; } } li { display: inherit; color: $text-color; a { color: inherit; text-align: left; padding: 0; \u0026:hover { color: $highlight-color; background-color: transparent; } } } } 具有上述样式的目录将如下所示：\n[图片]\n用法 如果要在降价内容中的特定点显示目录，请使用简码：toc.html\n1 {{ \u003ctoc\u003e }} 如果要在内容的开头显示目录，请将页面变量设置为 ：toc true\n1 toc: true 结论 总而言之，所提出的解决方案提供了两个用于自动创建目录的选项。您可以使用其中之一或两者。简码方法更直接，对您选择的雨果主题的实现的依赖性更小。此外，您可以将简码放置在降价内容中的任何位置。另一方面，单页模板/部分方法更依赖于主题，并且生成的目录在显示的内容中具有固定的位置。不过，只需启用相应的页面变量即可更轻松地使用。\n","description":"","tags":null,"title":"将目录添加到Hugo主题","uri":"/posts/2023/04/21/%E5%B0%86%E7%9B%AE%E5%BD%95%E6%B7%BB%E5%8A%A0%E5%88%B0hugo%E4%B8%BB%E9%A2%98/"},{"categories":null,"content":" 一种所有浏览器都支持的新方法，用于将颜色存储在 CSS 变量中并使用 SASS 函数对其进行修改。\nCSS变量很棒 我们都知道这一点。HSL 颜色值是最好的。同意！SASS颜色功能很棒。是的，没什么新鲜事。但是如何结合这些东西并在今天使用它们呢？有办法！\n我们为我们的框架开发了一种新的方法，该方法将本机变量（存储HSL颜色值）的灵活性与SASS函数的实用性相结合。\n👋 您第一次听说CodyHouse框架吗？\r* 开始使用\r* 浏览组件\r* 全球编辑\r问题所在 在我们的框架中，我们使用CSS变量。我们集成了 postcss-css-variables 插件的修改版本，为不支持它们的浏览器生成回退。我们更喜欢 CSS 变量而不是 SASS 变量，因为您可以在特定断点（或使用类）覆盖它们的值。事实证明，此功能对于开发我们的响应式间距和排版系统以及颜色主题特别有用。\n也就是说，以下是我们在启动框架（v 1.0.0）时定义颜色变量的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 :root, [data-theme=\"default\"] { // main --color-primary-darker: hsl(220, 90%, 36%); --color-primary-dark: hsl(220, 90%, 46%); --color-primary: hsl(220, 90%, 56%); --color-primary-light: hsl(220, 90%, 66%); --color-primary-lighter: hsl(220, 90%, 76%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); --color-accent-darker: hsl(355, 90%, 41%); --color-accent-dark: hsl(355, 90%, 51%); --color-accent: hsl(355, 90%, 61%); --color-accent-light: hsl(355, 90%, 71%); --color-accent-lighter: hsl(355, 90%, 81%); // color contrast --color-bg: hsl(0, 0%, 100%); --color-bg-a00: hsla(0, 0%, 100%, 0); --color-contrast-lower: hsl(0, 0%, 95%); --color-contrast-low: hsl(240, 1%, 83%); --color-contrast-medium: hsl(240, 1%, 48%); --color-contrast-high: hsl(240, 4%, 20%); --color-contrast-higher: hsl(240, 8%, 12%); --color-contrast-higher-a90: hsla(240, 8%, 12%, 0.9); // semantic --color-border: var(--color-contrast-low); // ... } HSL 颜色值很棒，因为它们使创建颜色变化变得直观。只需编辑色调、饱和度和亮度值。这些数字很容易阅读。\n但是，当我们开始处理组件时，我们意识到没有简单的方法来设置颜色的 alpha 值：\n1 2 3 .component { background-color: hsla(var(--color-primary), 0.2); // not working 😥 } 您可以将 CSS 变量包含在 SASS mixins 和函数中，但上面的代码会返回一个无效的值（–var（color） 被 hsl（x，x%，x%） 替换）。\n如何解决这个问题？\n测试 #1 - 将 CSS color-mod 函数与 PostCSS 插件🙅🏻 ♂️一起使用 首先，我们尝试使用 CSS原生颜色函数。\n1 2 3 .component { background-color: color-mod(var(--color-primary) alpha(20%)); } 它们很整洁，但远未得到主要浏览器的支持。我们尝试集成一些PostCSS插件来生成回退，但没有运气。我们在最终输出中不断出现错误，因此我们认为这种方法太不可靠了。\n测试 #2 - 为 alpha 值🙅🏻 ♂️设置 CSS 变量 因为我们的问题无法为颜色设置不透明度值，所以第二个方法是为 alpha 值创建 CSS 变量：\n1 2 3 4 :root, [data-theme=\"default\"] { --color-primary: hsl(220, 90%, 56%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); } 在组件级别，您可以通过应用 alpha 变量来设置 alpha 值：\n1 2 3 .component { background-color: var(--color-primary-a20); } 请记住，目标是将所有颜色值存储到单个文件中，以便整个系统易于维护。我们不能只在组件级别使用 hsla。_colors.scss\n虽然我们不是100%相信这个解决方案，但我们决定在框架的第一个版本中采用它。\n新解决方案 - 创建 SASS 混合蛋白以清理颜色混乱 🎉 事实证明，为 alpha 值创建变量是一个糟糕的解决方案，主要有两个原因：\n如果您在组件级别工作，则每当想要对颜色使用不同的 Alpha 值时，都必须切换到该文件。_colors.scss 因为我们的系统基于颜色主题（颜色是可互换的），所以如果你为一种颜色创建一个 alpha 变量，你必须对所有其他颜色做同样的事情。 我们又回到了原点。 以下是最终得到我们认为是一个很好的解决方案的过程：首先，我们尝试使用 mixin 来指定 alpha 值。此混合需要 3 个变量：、 和 。$property$color-variable$opacity\n我们会像这样使用mixin：\n1 2 3 .component { @include alpha(background-color, --color-primary, 0.2); } 虽然这是mixin的代码：\n1 2 3 4 5 6 @mixin alpha($property, $color-variable, $opacity) { $color-variable-h: var(#{$color-variable+'-h'}); $color-variable-s: var(#{$color-variable+'-s'}); $color-variable-l: var(#{$color-variable+'-l'}); #{$property}: hsla($color-variable-h, $color-variable-s, $color-variable-l, $opacity); } 为此，我们需要为每种颜色设置 3 个变量：\n:root, [data-theme=\"default\"] {\r--color-primary: hsl(220, 90%, 56%);\r--color-primary-h: 220;\r--color-primary-s: 90%;\r--color-primary-l: 56%;\r} 其中是色调值，是饱和度百分比，是亮度百分比（不，我们不想放弃HSL颜色值☝️）。--color-name-h--color-name-s--color-name-l\n仍然太复杂了，但我们正在到达某个地方。\n在这一点上，我们想出了创建我们自己的alpha SASS函数来替换mixin的想法。这将允许我们以更友好的方式编写 CSS 声明：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); } 下面是函数的代码：\n// return css color variable with different opacity value\r@function alpha($color, $opacity){\r$color: str-replace($color, 'var(');\r$color: str-replace($color, ')');\r$color-h: var(#{$color+'-h'});\r$color-s: var(#{$color+'-s'});\r$color-l: var(#{$color+'-l'});\r@return hsla($color-h, $color-s, $color-l, $opacity);\r}\r// replace substring with another string\r// credits: https://css-tricks.com/snippets/sass/str-replace-function/\r@function str-replace($string, $search, $replace: '') {\r$index: str-index($string, $search);\r@if $index {\r@return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);\r}\r@return $string;\r} 越来越近！困扰我们的最后一件事是必须为每种颜色（色调、饱和度、亮度）手动创建 3 个附加变量。这很烦人，因为您必须在修改颜色时更新这些变量的值。\n啊哈时刻意识到我们可以使用 SASS mixin 来定义每种颜色，以便我们可以在 CSS 中自动生成色调、饱和度和亮度值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @mixin defineColorHSL($color, $hue, $saturation, $lightness){ #{$color}: unquote(\"hsl(#{$hue}, #{$saturation}, #{$lightness})\");#{$color}-h: #{$hue};#{$color}-s: #{$saturation};#{$color}-l: #{$lightness}; } :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary, 220, 89%, 56%); @include defineColorHSL(--color-accent, 355, 90%, 61%); @include defineColorHSL(--color-black, 240, 8%, 12%); @include defineColorHSL(--color-white, 0, 0%, 100%); // color contrasts @include defineColorHSL(--color-bg, 0, 0%, 100%); @include defineColorHSL(--color-contrast-lower, 0, 0%, 95%); @include defineColorHSL(--color-contrast-low, 240, 1%, 83%); @include defineColorHSL(--color-contrast-medium, 240, 1%, 48%); @include defineColorHSL(--color-contrast-high, 240, 4%, 20%); @include defineColorHSL(--color-contrast-higher, 240, 8%, 12%); } 这种方法的好处是，您仍然以易于理解的语法声明颜色，并允许您创建修改 HSL 值的颜色变体：\n1 2 3 4 5 6 7 :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary-darker, 220, 90%, 36%); @include defineColorHSL(--color-primary-dark, 220, 90%, 46%); @include defineColorHSL(--color-primary, 220, 90%, 56%); @include defineColorHSL(--color-primary-light, 220, 90%, 66%); @include defineColorHSL(--color-primary-lighter, 220, 90%, 76%); } 如何在组件级别设置 alpha 值 在 SCSS 中，您可以使用 alpha 函数设置不透明度值：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); // it works 🎉 } 它有效🙌！我们刚刚推送了一个框架更新（v 1.1.0），其中包括新的mixins和一个更新的文件。_colors.scss\n使用此方法创建其他颜色函数 由于此方法允许您访问和修改色调、饱和度、亮度和 alpha 值，因此您可以为每个值创建一个函数！\n编辑亮度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function lightness($color, $lightnessMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, $color-s, calc(#{$color-l} * #{$lightnessMultiplier})); } .component { background-color: lightness(var(--color-primary), 1.2); } 编辑饱和度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function saturation($color, $saturationMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, calc(#{$color-s} * #{$saturationMultiplier}), $color-l); } .component { background-color: saturation(var(--color-primary), 1.2); } 结语 我们框架的主要目标是简化启动 Web 项目的过程。我们觉得我们正在朝着这个目标前进。如果您对我们可以改进的地方有任何建议，请与我们联系！欢迎任何反馈。\n","description":"","tags":["sass"],"title":"如何用SASS颜色函数和CSS变量","uri":"/posts/2023/04/19/%E5%A6%82%E4%BD%95%E7%94%A8sass%E9%A2%9C%E8%89%B2%E5%87%BD%E6%95%B0%E5%92%8Ccss%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"hugoTemplate Template 变量 在 Hugo 的模板中，变量是可扩展的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{ $variable := \"hello world\" }} {{/* 访问变量 */}} {{ $variable }} {{/* 进行计算 */}} {{ $sum := 1 + 1 }} {{ $sum }} {{/* 两个变量相加 */}} {{ $valueOne := 1 }} {{ $valueTwo := 2 }} {{ $result := add $valueOne $valueTwo }} {{ $result }} 内部变量 除了你自己定义的变量，Hugo 也会在模板中自动创建一些内部变量，以便在渲染页面时为你提供有用的信息。这些变量通常用于控制网站的样式和页面布局，以及访问站点中的内容和元数据。\n以下是一些常见的内部变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 {{/* 站点元数据 */}} {{ .Site.Title }} {{ .Site.Params.author }} {{ .Site.Params.description }} {{/* 页面元数据 */}} {{ .Title }} {{ .Params.date }} {{ .Params.author }} {{ .Description }} {{ .Type }} {{ .Content }} {{/* 访问站点的相关页面 */}} {{ .Site.GetPage \"section\" \"blog\" }} {{ .Site.GetPage \"url\" \"/\" }} {{ .Site.GetPage \"permalink\" \"/blog/\" }} {{/* 访问站点相关资源 */}} {{ .Site.GetPage \"page\" \"/css/styles.css\" }} {{ .Site.GetPage \"page\" \"/images/banner.jpg\" }} {{/* 迭代站点相关内容 */}} {{ range .Data.Pages }} {{ .Render \"summary\" }} {{ end }} {{/* 参数定位 */}} {{ $.Param \"foo\" }} 访问指定字段 在 Hugo 模板中，你可以访问网站元数据和内容页面中的字段并将其用于渲染。 1 2 3 4 5 6 7 {{ .Site.Params.author }} {{ .Site.Params.description }} {{ .Title }} {{ .Content }} {{ .Params.date }} {{ .Params.author }} {{ .Params.tags }} 变量 每个Go模板获得一个数据对象。在Hugo中，每个模板都传递一个Page。在下面的示例中，. title是Page变量中可访问的元素之一。由于Page是模板的默认作用域，因此当前作用域中的Title元素(。-“点”)可以通过点前缀(.Title)访问:\n1 \u003ctitle\u003e{{ .Title }}\u003c/title\u003e 值也可以存储在自定义变量中并在以后引用:\n自定义变量需要以$作为前缀。 1 2 {{ $address := \"123 Main St.\" }} {{ $address }} 变量可以使用=操作符重新定义。下面的示例在主页上打印“Var is Hugo Home”，在所有其他页面上打印“Var is Hugo page”:\n1 2 3 4 5 {{ $var := \"Hugo Page\" }} {{ if .IsHome }} {{ $var = \"Hugo Home\" }} {{ end }} Var is {{ $var }} ","description":"","tags":["Hugo"],"title":"Hugo Template 变量的定义","uri":"/posts/2023/04/19/hugo-template-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"categories":null,"content":" 如果您对 Hugo 主题进行了修改，并且希望将这些修改提交到 Git 仓库中，则应该考虑以下两种情况： 如果您从 Hugo 主题库中下载了某个主题，并在其基础上进行修改，则建议在您自己的 Git 仓库中提交修改。这样，您可以更轻松地管理您所做的所有修改，并随时更新该主题的原始版本。\n如果您在 GitHub 中发现了某个 Hugo 主题，并且您对该主题进行了修改，则可以考虑 fork 该主题的仓库，并将您所做的修改提交到 fork 的仓库中。当您的修改被审核后，您可以提交 pull request 到原始仓库中，以便作者将您的修改合并到主题中。\n需要注意的是，无论您将修改提交到哪个仓库中，都需要遵循开源许可协议和作者的许可条件。如果您不确定是否可以在特定情况下进行修改，请查看主题的文档和许可证。 ","description":"","tags":["Hugo"],"title":"Hugo Themes主题文件有修改改动的内容应该提交到哪个git仓库呢","uri":"/posts/2023/04/19/hugo-themes%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E6%9C%89%E4%BF%AE%E6%94%B9%E6%94%B9%E5%8A%A8%E7%9A%84%E5%86%85%E5%AE%B9%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BA%A4%E5%88%B0%E5%93%AA%E4%B8%AAgit%E4%BB%93%E5%BA%93%E5%91%A2/"},{"categories":null,"content":" Hugo 的语法文档可以在 Hugo 官方网站（https://gohugo.io/documentation/）上找到，您可以根据需要查看以下文档：\n快速入门（https://gohugo.io/getting-started/quick-start/）介绍了如何安装 Hugo 并创建新的站点。 Hugo 基础语法（https://gohugo.io/content-management/syntax/）文档详细介绍了 Hugo 的基本语法，如如何创建页面、如何定义页面元数据、如何使用 Markdown 语法等。 主题开发文档（https://gohugo.io/templates/）介绍了如何使用 Hugo 模板来创建自定义主题。 内容管理文档（https://gohugo.io/content-management/organization/）介绍了如何组织和管理站点内容。 部署文档（https://gohugo.io/hosting-and-deployment/) 介绍了如何将站点部署到各种平台和服务上，包括 GitHub Pages、Netlify、Amazon S3 等。 在 Hugo 官方网站上，您还可以找到其他相关文档和资源，例如社区主题和插件，以及 Hugo 的 GitHub 存储库。此外，Hugo 的文档是开源的，您也可以在 Hugo 的 GitHub 存储库（https://github.com/gohugoio/hugo）中找到完整的文档源码。 ","description":"","tags":["Hugo"],"title":"Hugo 语法文档哪里看","uri":"/posts/2023/04/19/hugo-%E8%AF%AD%E6%B3%95%E6%96%87%E6%A1%A3%E5%93%AA%E9%87%8C%E7%9C%8B/"},{"categories":null,"content":" section 2 section 2.1 section 2.2 section 2.3 section 2 section 2.1 section 2.2 section 2.3 如果您在 Git 中添加了一个子模块，但是现在要卸载它，可以按照以下步骤执行：\n删除 .gitmodules 文件中子模块的条目。 打开 .gitmodules 文件并找到您要删除的子模块条目，然后将其删除。例如： 1 2 3 [submodule \"path/to/submodule\"] path = path/to/submodule url = https://github.com/username/repo.git ","description":"","tags":["git"],"title":"Git Submodule 卸载模块","uri":"/posts/2023/04/18/git-submodule-%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Hugo自定义短代码 在 Hugo 中，你可以使用自定义短代码来生成模板中的动态内容。自定义短代码是一段用于生成特定内容的模板代码片段，这个代码片段可以通过简单的一行代码在模板中调用。\n下面是一个简单的例子，演示如何在 Hugo 中定义和使用自定义短代码。我们将定义一个短代码 {{myShortcode }}，并让它生成一段简单的 HTML。\n在 Hugo 的根目录下，创建一个名为 layouts/shortcodes 的文件夹。\n在 layouts/shortcodes 文件夹中，创建一个名为 myShortcode.html 的文件。\n在 myShortcode.html 文件中，添加以下代码片段：\n1 \u003cp\u003eThis is my custom shortcode!\u003c/p\u003e 在模板中使用自定义短代码 **{{{myShortcode }}}。**例如： 1 2 3 4 5 6 7 8 9 10 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e{{ .Title }}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e {{\u0026#123;myShortcode \u0026#125;}} \u003c/body\u003e \u003c/html\u003e 在浏览器中查看生成的页面，你应该看到 “This is my custom shortcode!” 这段文字。 总的来说，自定义短代码是一个十分有用的功能，它让你可以在 Hugo 中轻松地生成各种动态内容。\n","description":"","tags":["Hugo"],"title":"Hugo自定义短代码","uri":"/posts/2023/04/18/hugo%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%AD%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":" 变量 描述 .Site 网站级别的变量，用于存储网站的全部信息，包括站点标题、url、作者等信息。 Site.BuildDrafts 如果设置为 true，则 Hugo 会对所有草稿页面进行构建。 Site.BuildFuture 如果设置为 true，则 Hugo 会对将来发布的页面进行构建。 Site.BuildExpired 如果设置为 true，则 Hugo 会对过期的页面进行构建。 Site.Charset 设置网站的字符编码，默认为 utf-8。 Site.LanguageCode 设置网站的语言代码，默认为 en-us。 Site.Title 网站标题。 Site.Params 网站中自定义的变量的命名空间，可以在配置文件中定义。 Site.Menus 网站菜单项的配置项。 Site.Home 网站首页的配置项。 Site.Pages 网站中所有页面的集合。 Site.RegularPages 网站中所有“正式”页面的集合，不包括草稿、过期等页面。 Site.AllPages 网站中所有页面（包括草稿、过期等）的集合。 Site.Data 网站中的数据文件。 Site.Taxonomies 网站中分类和标签的信息。 Site.Taxonomies. 网站中指定分类或标签的信息， 为分类或标签的名称。 .CurrentDate 当前时间，格式为 2006-01-02。 .Date 文章的日期。 .PublishDate 文章的发布日期。 .ExpiryDate 文章的过期日期。 .Lastmod 文章最后修改时间。 .Permalink 页面的永久链接。 .FuzzyWordCount 计算页面的模糊字数（即忽略 HTML、注释等元素的总字数）。 .PageNumber 如果在多页列表中，则为当前页面的序号。 .Paginate 分页器的配置信息。 .Paginator 分页器的结构体变量。 .WordCount 页面的总字数。 .Title 文章或页面的标题。 .Description 文章或页面的描述。 .Summary 文章或页面的摘要。 .Content 页面的主要内容。 .Params 页面的自定义变量的命名空间，可以在 Markdown 页面中定义。 .Site.Params. 等同于 .Params.，但是在 Hugo 中建议使用前者。 .Resources 页面中的资源，如图片、CSS、JavaScript 等。 .Params. 页面中自定义变量的值，可以在 Markdown 或配置文件中定义。 .ContentBaseName 页面的文件名（不包括扩展名）。 .FileName 页面的文件名（包括扩展名）。 .File 页面的文件信息，包括文件路径、名称、扩展名等。 .Section 当前页面所在的 section 名称，由页面的路径决定。 .Site.GetPage 根据指定路径获取页面信息。 .Site.GetPage 根据指定路径获取页面信息。 .RelLangURL 当前页面在指定语言下的 URL。 .RelPermalink 当前页面的相对 URL。 .RSSLink 当前页面 RSS 订阅的链接。 .Site.Author. 网站作者的信息， 可以是 name、email、bio 等。 .Site.Params. 获取网站中自定义变量的值。 with 可以嵌套在 range 中使用，用于在 range 的作用域内定义变量。 range 遍历集合，并将每个元素赋值给指定变量，可以使用 with 定义变量。 if 条件控制语句。 else 与 if 配合使用，表示 if 条件不成立时执行的语句。 partial 载入指定名称的 partial 方件并进行解析。 block 定义重载块，用于在父模板中指定可用于被子模板覆盖的区域。 define 定义 template 变量。 template 引用指定名称的 template。 shortcode Hugo 中内置的短代码语法，用于快速插入特定块的内容，例如音频、视频、图集等。 ","description":"","tags":["Hugo"],"title":"Hugo的所有变量整理表","uri":"/posts/2023/04/18/hugo%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E6%95%B4%E7%90%86%E8%A1%A8/"},{"categories":null,"content":"hugo new post/ 如果有很多文章了怎么防止创建的时候md文件名重复 在使用 hugo new 命令创建新文章时，可以结合当前的时间戳来避免文件名重复。具体操作如下：\n在 config.toml 或 config.yaml 文件中设置 uglyUrls 为 true，这将使 Hugo 自动生成文件的 URL 格式为 domain.com/post/index.html，而不是默认的 domain.com/post/。 1 2 # config.toml uglyUrls = true 创建新文章时，使用当前的时间戳添加到文件名后面，例如： 1 $ hugo new post/my-new-post-1634090882.md 这里的 1634090882 表示当前的 Unix 时间戳，可以通过以下命令获取：\n1 $ date +%s 如果在命令行中不想手动输入时间戳，可以使用以下命令来自动生成：\n1 $ hugo new post/$(date +%Y-%m-%d)-my-new-post.md 这样会创建一个类似 2022-10-13-my-new-post.md 的文件。\n使用时间戳可以确保每个文件名都不同，避免重复。\n","description":"","tags":["Hugo"],"title":"Hugo New Post Repeat","uri":"/posts/2023/04/18/hugo-new-post-repeat/"},{"categories":null,"content":"asdasda ","description":"","tags":null,"title":"Gndex","uri":"/posts/gndex/"},{"categories":["javascript","前端"],"content":"asdasda-1 sdfadsf asdfasdf\n","description":"","tags":null,"title":"Js20year-1","uri":"/posts/js20year/"},{"categories":null,"content":"00123-1 ","description":"","tags":["Hugo","Vue","React","nodeJS","Notion","blog","life","travel","golang","java","ecmascript","typescript","工程化","Vim"],"title":"我的文章标题-1","uri":"/posts/hello-world/"}]