[{"categories":null,"content":" 一种所有浏览器都支持的新方法，用于将颜色存储在 CSS 变量中并使用 SASS 函数对其进行修改。\nCSS 变量很棒。我们都知道这一点。HSL 颜色值是最好的。同意！SASS颜色功能很棒。是的，没什么新鲜事。但是如何结合这些东西并在今天使用它们呢？有办法！\n我们为我们的框架开发了一种新的方法，该方法将本机变量（存储HSL颜色值）的灵活性与SASS函数的实用性相结合。\n👋 您第一次听说CodyHouse框架吗？\r* 开始使用\r* 浏览组件\r* 全球编辑\r问题所在 在我们的框架中，我们使用CSS变量。我们集成了 postcss-css-variables 插件的修改版本，为不支持它们的浏览器生成回退。我们更喜欢 CSS 变量而不是 SASS 变量，因为您可以在特定断点（或使用类）覆盖它们的值。事实证明，此功能对于开发我们的响应式间距和排版系统以及颜色主题特别有用。\n也就是说，以下是我们在启动框架（v 1.0.0）时定义颜色变量的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 :root, [data-theme=\"default\"] { // main --color-primary-darker: hsl(220, 90%, 36%); --color-primary-dark: hsl(220, 90%, 46%); --color-primary: hsl(220, 90%, 56%); --color-primary-light: hsl(220, 90%, 66%); --color-primary-lighter: hsl(220, 90%, 76%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); --color-accent-darker: hsl(355, 90%, 41%); --color-accent-dark: hsl(355, 90%, 51%); --color-accent: hsl(355, 90%, 61%); --color-accent-light: hsl(355, 90%, 71%); --color-accent-lighter: hsl(355, 90%, 81%); // color contrast --color-bg: hsl(0, 0%, 100%); --color-bg-a00: hsla(0, 0%, 100%, 0); --color-contrast-lower: hsl(0, 0%, 95%); --color-contrast-low: hsl(240, 1%, 83%); --color-contrast-medium: hsl(240, 1%, 48%); --color-contrast-high: hsl(240, 4%, 20%); --color-contrast-higher: hsl(240, 8%, 12%); --color-contrast-higher-a90: hsla(240, 8%, 12%, 0.9); // semantic --color-border: var(--color-contrast-low); // ... } HSL 颜色值很棒，因为它们使创建颜色变化变得直观。只需编辑色调、饱和度和亮度值。这些数字很容易阅读。\n但是，当我们开始处理组件时，我们意识到没有简单的方法来设置颜色的 alpha 值：\n1 2 3 .component { background-color: hsla(var(--color-primary), 0.2); // not working 😥 } 您可以将 CSS 变量包含在 SASS mixins 和函数中，但上面的代码会返回一个无效的值（–var（color） 被 hsl（x，x%，x%） 替换）。\n如何解决这个问题？\n测试 #1 - 将 CSS color-mod 函数与 PostCSS 插件🙅🏻 ♂️一起使用 首先，我们尝试使用 CSS原生颜色函数。\n1 2 3 .component { background-color: color-mod(var(--color-primary) alpha(20%)); } 它们很整洁，但远未得到主要浏览器的支持。我们尝试集成一些PostCSS插件来生成回退，但没有运气。我们在最终输出中不断出现错误，因此我们认为这种方法太不可靠了。\n测试 #2 - 为 alpha 值🙅🏻 ♂️设置 CSS 变量 因为我们的问题无法为颜色设置不透明度值，所以第二个方法是为 alpha 值创建 CSS 变量：\n1 2 3 4 :root, [data-theme=\"default\"] { --color-primary: hsl(220, 90%, 56%); --color-primary-a20: hsla(220, 90%, 56%, 0.2); } 在组件级别，您可以通过应用 alpha 变量来设置 alpha 值：\n1 2 3 .component { background-color: var(--color-primary-a20); } 请记住，目标是将所有颜色值存储到单个文件中，以便整个系统易于维护。我们不能只在组件级别使用 hsla。_colors.scss\n虽然我们不是100%相信这个解决方案，但我们决定在框架的第一个版本中采用它。\n新解决方案 - 创建 SASS 混合蛋白以清理颜色混乱 🎉 事实证明，为 alpha 值创建变量是一个糟糕的解决方案，主要有两个原因：\n如果您在组件级别工作，则每当想要对颜色使用不同的 Alpha 值时，都必须切换到该文件。_colors.scss 因为我们的系统基于颜色主题（颜色是可互换的），所以如果你为一种颜色创建一个 alpha 变量，你必须对所有其他颜色做同样的事情。 我们又回到了原点。 以下是最终得到我们认为是一个很好的解决方案的过程：首先，我们尝试使用 mixin 来指定 alpha 值。此混合需要 3 个变量：、 和 。$property$color-variable$opacity\n我们会像这样使用mixin：\n1 2 3 .component { @include alpha(background-color, --color-primary, 0.2); } 虽然这是mixin的代码：\n1 2 3 4 5 6 @mixin alpha($property, $color-variable, $opacity) { $color-variable-h: var(#{$color-variable+'-h'}); $color-variable-s: var(#{$color-variable+'-s'}); $color-variable-l: var(#{$color-variable+'-l'}); #{$property}: hsla($color-variable-h, $color-variable-s, $color-variable-l, $opacity); } 为此，我们需要为每种颜色设置 3 个变量：\n:root, [data-theme=\"default\"] {\r--color-primary: hsl(220, 90%, 56%);\r--color-primary-h: 220;\r--color-primary-s: 90%;\r--color-primary-l: 56%;\r} 其中是色调值，是饱和度百分比，是亮度百分比（不，我们不想放弃HSL颜色值☝️）。--color-name-h--color-name-s--color-name-l\n仍然太复杂了，但我们正在到达某个地方。\n在这一点上，我们想出了创建我们自己的alpha SASS函数来替换mixin的想法。这将允许我们以更友好的方式编写 CSS 声明：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); } 下面是函数的代码：\n// return css color variable with different opacity value\r@function alpha($color, $opacity){\r$color: str-replace($color, 'var(');\r$color: str-replace($color, ')');\r$color-h: var(#{$color+'-h'});\r$color-s: var(#{$color+'-s'});\r$color-l: var(#{$color+'-l'});\r@return hsla($color-h, $color-s, $color-l, $opacity);\r}\r// replace substring with another string\r// credits: https://css-tricks.com/snippets/sass/str-replace-function/\r@function str-replace($string, $search, $replace: '') {\r$index: str-index($string, $search);\r@if $index {\r@return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);\r}\r@return $string;\r} 越来越近！困扰我们的最后一件事是必须为每种颜色（色调、饱和度、亮度）手动创建 3 个附加变量。这很烦人，因为您必须在修改颜色时更新这些变量的值。\n啊哈时刻意识到我们可以使用 SASS mixin 来定义每种颜色，以便我们可以在 CSS 中自动生成色调、饱和度和亮度值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @mixin defineColorHSL($color, $hue, $saturation, $lightness){ #{$color}: unquote(\"hsl(#{$hue}, #{$saturation}, #{$lightness})\");#{$color}-h: #{$hue};#{$color}-s: #{$saturation};#{$color}-l: #{$lightness}; } :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary, 220, 89%, 56%); @include defineColorHSL(--color-accent, 355, 90%, 61%); @include defineColorHSL(--color-black, 240, 8%, 12%); @include defineColorHSL(--color-white, 0, 0%, 100%); // color contrasts @include defineColorHSL(--color-bg, 0, 0%, 100%); @include defineColorHSL(--color-contrast-lower, 0, 0%, 95%); @include defineColorHSL(--color-contrast-low, 240, 1%, 83%); @include defineColorHSL(--color-contrast-medium, 240, 1%, 48%); @include defineColorHSL(--color-contrast-high, 240, 4%, 20%); @include defineColorHSL(--color-contrast-higher, 240, 8%, 12%); } 这种方法的好处是，您仍然以易于理解的语法声明颜色，并允许您创建修改 HSL 值的颜色变体：\n1 2 3 4 5 6 7 :root, [data-theme=\"default\"] { @include defineColorHSL(--color-primary-darker, 220, 90%, 36%); @include defineColorHSL(--color-primary-dark, 220, 90%, 46%); @include defineColorHSL(--color-primary, 220, 90%, 56%); @include defineColorHSL(--color-primary-light, 220, 90%, 66%); @include defineColorHSL(--color-primary-lighter, 220, 90%, 76%); } 如何在组件级别设置 alpha 值 在 SCSS 中，您可以使用 alpha 函数设置不透明度值：\n1 2 3 .component { background-color: alpha(var(--color-primary), 0.2); // it works 🎉 } 它有效🙌！我们刚刚推送了一个框架更新（v 1.1.0），其中包括新的mixins和一个更新的文件。_colors.scss\n使用此方法创建其他颜色函数 由于此方法允许您访问和修改色调、饱和度、亮度和 alpha 值，因此您可以为每个值创建一个函数！\n编辑亮度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function lightness($color, $lightnessMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, $color-s, calc(#{$color-l} * #{$lightnessMultiplier})); } .component { background-color: lightness(var(--color-primary), 1.2); } 编辑饱和度：\n1 2 3 4 5 6 7 8 9 10 11 12 @function saturation($color, $saturationMultiplier){ $color: str-replace($color, 'var('); $color: str-replace($color, ')'); $color-h: var(#{$color+'-h'}); $color-s: var(#{$color+'-s'}); $color-l: var(#{$color+'-l'}); @return hsl($color-h, calc(#{$color-s} * #{$saturationMultiplier}), $color-l); } .component { background-color: saturation(var(--color-primary), 1.2); } 结语 我们框架的主要目标是简化启动 Web 项目的过程。我们觉得我们正在朝着这个目标前进。如果您对我们可以改进的地方有任何建议，请与我们联系！欢迎任何反馈。\n","description":"","tags":["sass"],"title":"如何用SASS颜色函数和CSS变量","uri":"/posts/2023/04/19/%E5%A6%82%E4%BD%95%E7%94%A8sass%E9%A2%9C%E8%89%B2%E5%87%BD%E6%95%B0%E5%92%8Ccss%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"Template 变量 在 Hugo 的模板中，变量是可扩展的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{ $variable := \"hello world\" }} {{/* 访问变量 */}} {{ $variable }} {{/* 进行计算 */}} {{ $sum := 1 + 1 }} {{ $sum }} {{/* 两个变量相加 */}} {{ $valueOne := 1 }} {{ $valueTwo := 2 }} {{ $result := add $valueOne $valueTwo }} {{ $result }} 内部变量 除了你自己定义的变量，Hugo 也会在模板中自动创建一些内部变量，以便在渲染页面时为你提供有用的信息。这些变量通常用于控制网站的样式和页面布局，以及访问站点中的内容和元数据。\n以下是一些常见的内部变量： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 {{/* 站点元数据 */}} {{ .Site.Title }} {{ .Site.Params.author }} {{ .Site.Params.description }} {{/* 页面元数据 */}} {{ .Title }} {{ .Params.date }} {{ .Params.author }} {{ .Description }} {{ .Type }} {{ .Content }} {{/* 访问站点的相关页面 */}} {{ .Site.GetPage \"section\" \"blog\" }} {{ .Site.GetPage \"url\" \"/\" }} {{ .Site.GetPage \"permalink\" \"/blog/\" }} {{/* 访问站点相关资源 */}} {{ .Site.GetPage \"page\" \"/css/styles.css\" }} {{ .Site.GetPage \"page\" \"/images/banner.jpg\" }} {{/* 迭代站点相关内容 */}} {{ range .Data.Pages }} {{ .Render \"summary\" }} {{ end }} {{/* 参数定位 */}} {{ $.Param \"foo\" }} 访问指定字段 在 Hugo 模板中，你可以访问网站元数据和内容页面中的字段并将其用于渲染。 1 2 3 4 5 6 7 {{ .Site.Params.author }} {{ .Site.Params.description }} {{ .Title }} {{ .Content }} {{ .Params.date }} {{ .Params.author }} {{ .Params.tags }} 变量 每个Go模板获得一个数据对象。在Hugo中，每个模板都传递一个Page。在下面的示例中，. title是Page变量中可访问的元素之一。由于Page是模板的默认作用域，因此当前作用域中的Title元素(。-“点”)可以通过点前缀(.Title)访问:\n1 \u003ctitle\u003e{{ .Title }}\u003c/title\u003e 值也可以存储在自定义变量中并在以后引用:\n自定义变量需要以$作为前缀。 1 2 {{ $address := \"123 Main St.\" }} {{ $address }} 变量可以使用=操作符重新定义。下面的示例在主页上打印“Var is Hugo Home”，在所有其他页面上打印“Var is Hugo page”:\n1 2 3 4 5 {{ $var := \"Hugo Page\" }} {{ if .IsHome }} {{ $var = \"Hugo Home\" }} {{ end }} Var is {{ $var }} ","description":"","tags":["Hugo"],"title":"Hugo Template 变量的定义","uri":"/posts/2023/04/19/hugo-template-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/"},{"categories":null,"content":" 如果您对 Hugo 主题进行了修改，并且希望将这些修改提交到 Git 仓库中，则应该考虑以下两种情况： 如果您从 Hugo 主题库中下载了某个主题，并在其基础上进行修改，则建议在您自己的 Git 仓库中提交修改。这样，您可以更轻松地管理您所做的所有修改，并随时更新该主题的原始版本。\n如果您在 GitHub 中发现了某个 Hugo 主题，并且您对该主题进行了修改，则可以考虑 fork 该主题的仓库，并将您所做的修改提交到 fork 的仓库中。当您的修改被审核后，您可以提交 pull request 到原始仓库中，以便作者将您的修改合并到主题中。\n需要注意的是，无论您将修改提交到哪个仓库中，都需要遵循开源许可协议和作者的许可条件。如果您不确定是否可以在特定情况下进行修改，请查看主题的文档和许可证。 ","description":"","tags":["Hugo"],"title":"Hugo Themes主题文件有修改改动的内容应该提交到哪个git仓库呢","uri":"/posts/2023/04/19/hugo-themes%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E6%9C%89%E4%BF%AE%E6%94%B9%E6%94%B9%E5%8A%A8%E7%9A%84%E5%86%85%E5%AE%B9%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BA%A4%E5%88%B0%E5%93%AA%E4%B8%AAgit%E4%BB%93%E5%BA%93%E5%91%A2/"},{"categories":null,"content":" Hugo 的语法文档可以在 Hugo 官方网站（https://gohugo.io/documentation/）上找到，您可以根据需要查看以下文档：\n快速入门（https://gohugo.io/getting-started/quick-start/）介绍了如何安装 Hugo 并创建新的站点。 Hugo 基础语法（https://gohugo.io/content-management/syntax/）文档详细介绍了 Hugo 的基本语法，如如何创建页面、如何定义页面元数据、如何使用 Markdown 语法等。 主题开发文档（https://gohugo.io/templates/）介绍了如何使用 Hugo 模板来创建自定义主题。 内容管理文档（https://gohugo.io/content-management/organization/）介绍了如何组织和管理站点内容。 部署文档（https://gohugo.io/hosting-and-deployment/) 介绍了如何将站点部署到各种平台和服务上，包括 GitHub Pages、Netlify、Amazon S3 等。 在 Hugo 官方网站上，您还可以找到其他相关文档和资源，例如社区主题和插件，以及 Hugo 的 GitHub 存储库。此外，Hugo 的文档是开源的，您也可以在 Hugo 的 GitHub 存储库（https://github.com/gohugoio/hugo）中找到完整的文档源码。 ","description":"","tags":["Hugo"],"title":"Hugo 语法文档哪里看","uri":"/posts/2023/04/19/hugo-%E8%AF%AD%E6%B3%95%E6%96%87%E6%A1%A3%E5%93%AA%E9%87%8C%E7%9C%8B/"},{"categories":null,"content":" section 2 section 2.1 section 2.2 section 2.3 section 2 section 2.1 section 2.2 section 2.3 如果您在 Git 中添加了一个子模块，但是现在要卸载它，可以按照以下步骤执行：\n删除 .gitmodules 文件中子模块的条目。 打开 .gitmodules 文件并找到您要删除的子模块条目，然后将其删除。例如： 1 2 3 [submodule \"path/to/submodule\"] path = path/to/submodule url = https://github.com/username/repo.git ","description":"","tags":["git"],"title":"Git Submodule 卸载模块","uri":"/posts/2023/04/18/git-submodule-%E5%8D%B8%E8%BD%BD%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"Hugo自定义短代码 在 Hugo 中，你可以使用自定义短代码来生成模板中的动态内容。自定义短代码是一段用于生成特定内容的模板代码片段，这个代码片段可以通过简单的一行代码在模板中调用。\n下面是一个简单的例子，演示如何在 Hugo 中定义和使用自定义短代码。我们将定义一个短代码 {{myShortcode }}，并让它生成一段简单的 HTML。\n在 Hugo 的根目录下，创建一个名为 layouts/shortcodes 的文件夹。\n在 layouts/shortcodes 文件夹中，创建一个名为 myShortcode.html 的文件。\n在 myShortcode.html 文件中，添加以下代码片段：\n1 \u003cp\u003eThis is my custom shortcode!\u003c/p\u003e 在模板中使用自定义短代码 **{{{myShortcode }}}。**例如： 1 2 3 4 5 6 7 8 9 10 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e{{ .Title }}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e {{\u0026#123;myShortcode \u0026#125;}} \u003c/body\u003e \u003c/html\u003e 在浏览器中查看生成的页面，你应该看到 “This is my custom shortcode!” 这段文字。 总的来说，自定义短代码是一个十分有用的功能，它让你可以在 Hugo 中轻松地生成各种动态内容。\n","description":"","tags":["Hugo"],"title":"Hugo自定义短代码","uri":"/posts/2023/04/18/hugo%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9F%AD%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":" 变量 描述 .Site 网站级别的变量，用于存储网站的全部信息，包括站点标题、url、作者等信息。 Site.BuildDrafts 如果设置为 true，则 Hugo 会对所有草稿页面进行构建。 Site.BuildFuture 如果设置为 true，则 Hugo 会对将来发布的页面进行构建。 Site.BuildExpired 如果设置为 true，则 Hugo 会对过期的页面进行构建。 Site.Charset 设置网站的字符编码，默认为 utf-8。 Site.LanguageCode 设置网站的语言代码，默认为 en-us。 Site.Title 网站标题。 Site.Params 网站中自定义的变量的命名空间，可以在配置文件中定义。 Site.Menus 网站菜单项的配置项。 Site.Home 网站首页的配置项。 Site.Pages 网站中所有页面的集合。 Site.RegularPages 网站中所有“正式”页面的集合，不包括草稿、过期等页面。 Site.AllPages 网站中所有页面（包括草稿、过期等）的集合。 Site.Data 网站中的数据文件。 Site.Taxonomies 网站中分类和标签的信息。 Site.Taxonomies. 网站中指定分类或标签的信息， 为分类或标签的名称。 .CurrentDate 当前时间，格式为 2006-01-02。 .Date 文章的日期。 .PublishDate 文章的发布日期。 .ExpiryDate 文章的过期日期。 .Lastmod 文章最后修改时间。 .Permalink 页面的永久链接。 .FuzzyWordCount 计算页面的模糊字数（即忽略 HTML、注释等元素的总字数）。 .PageNumber 如果在多页列表中，则为当前页面的序号。 .Paginate 分页器的配置信息。 .Paginator 分页器的结构体变量。 .WordCount 页面的总字数。 .Title 文章或页面的标题。 .Description 文章或页面的描述。 .Summary 文章或页面的摘要。 .Content 页面的主要内容。 .Params 页面的自定义变量的命名空间，可以在 Markdown 页面中定义。 .Site.Params. 等同于 .Params.，但是在 Hugo 中建议使用前者。 .Resources 页面中的资源，如图片、CSS、JavaScript 等。 .Params. 页面中自定义变量的值，可以在 Markdown 或配置文件中定义。 .ContentBaseName 页面的文件名（不包括扩展名）。 .FileName 页面的文件名（包括扩展名）。 .File 页面的文件信息，包括文件路径、名称、扩展名等。 .Section 当前页面所在的 section 名称，由页面的路径决定。 .Site.GetPage 根据指定路径获取页面信息。 .Site.GetPage 根据指定路径获取页面信息。 .RelLangURL 当前页面在指定语言下的 URL。 .RelPermalink 当前页面的相对 URL。 .RSSLink 当前页面 RSS 订阅的链接。 .Site.Author. 网站作者的信息， 可以是 name、email、bio 等。 .Site.Params. 获取网站中自定义变量的值。 with 可以嵌套在 range 中使用，用于在 range 的作用域内定义变量。 range 遍历集合，并将每个元素赋值给指定变量，可以使用 with 定义变量。 if 条件控制语句。 else 与 if 配合使用，表示 if 条件不成立时执行的语句。 partial 载入指定名称的 partial 方件并进行解析。 block 定义重载块，用于在父模板中指定可用于被子模板覆盖的区域。 define 定义 template 变量。 template 引用指定名称的 template。 shortcode Hugo 中内置的短代码语法，用于快速插入特定块的内容，例如音频、视频、图集等。 ","description":"","tags":["Hugo"],"title":"Hugo的所有变量整理表","uri":"/posts/2023/04/18/hugo%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E6%95%B4%E7%90%86%E8%A1%A8/"},{"categories":null,"content":"hugo new post/ 如果有很多文章了怎么防止创建的时候md文件名重复 在使用 hugo new 命令创建新文章时，可以结合当前的时间戳来避免文件名重复。具体操作如下：\n在 config.toml 或 config.yaml 文件中设置 uglyUrls 为 true，这将使 Hugo 自动生成文件的 URL 格式为 domain.com/post/index.html，而不是默认的 domain.com/post/。 1 2 # config.toml uglyUrls = true 创建新文章时，使用当前的时间戳添加到文件名后面，例如： 1 $ hugo new post/my-new-post-1634090882.md 这里的 1634090882 表示当前的 Unix 时间戳，可以通过以下命令获取：\n1 $ date +%s 如果在命令行中不想手动输入时间戳，可以使用以下命令来自动生成：\n1 $ hugo new post/$(date +%Y-%m-%d)-my-new-post.md 这样会创建一个类似 2022-10-13-my-new-post.md 的文件。\n使用时间戳可以确保每个文件名都不同，避免重复。\n","description":"","tags":["Hugo"],"title":"Hugo New Post Repeat","uri":"/posts/2023/04/18/hugo-new-post-repeat/"},{"categories":null,"content":"asdasda ","description":"","tags":null,"title":"Gndex","uri":"/posts/gndex/"},{"categories":["javascript","前端"],"content":"asdasda-1 sdfadsf asdfasdf\n","description":"","tags":null,"title":"Js20year-1","uri":"/posts/js20year/"},{"categories":null,"content":"00123-1 ","description":"","tags":["Hugo","Vue","React","nodeJS","Notion","blog","life","travel","golang","java","ecmascript","typescript","工程化","Vim"],"title":"我的文章标题-1","uri":"/posts/hello-world/"}]